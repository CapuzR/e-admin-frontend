function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _asyncToGenerator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _instanceof(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else {
        return left instanceof right;
    }
}
function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
        }
        ownKeys.forEach(function(key) {
            _defineProperty(target, key, source[key]);
        });
    }
    return target;
}
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) {
            symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
        }
        keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpreadProps(target, source) {
    source = source != null ? source : {};
    if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
        ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
var _typeof = function(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
};
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
import regeneratorRuntime from "regenerator-runtime";
import { DelegationChain } from "@dfinity/identity";
import { Actor, HttpAgent } from "@dfinity/agent";
import { isDelegationValid } from "./util";
import { ICStorage } from "./storage";
import * as _ms from "./methods";
import { TransactionMessageKind, TransactionType } from "./types";
import { AstroXIdentity } from "./identity";
import { BridgeErrors } from "./errors";
var KEY_ICSTORAGE_CACHEKEY = "cacheKey";
var KEY_ICSTORAGE_CHAIN = "chain";
var KEY_ICSTORAGE_WALLET = "wallet";
var KEY_ICSTORAGE_CONFIRM = "confirm";
var KEY_ICSTORAGE_HOST = "host";
export var AstroXWebViewHandler = /*#__PURE__*/ function() {
    "use strict";
    function AstroXWebViewHandler(_identity, _agent, _chain, _storage, _cacheKey, _wallet, _confirm) {
        _classCallCheck(this, AstroXWebViewHandler);
        this._identity = _identity;
        this._agent = _agent;
        this._chain = _chain;
        this._storage = _storage;
        this._cacheKey = _cacheKey;
        this._wallet = _wallet;
        this._confirm = _confirm;
        this._isReady = false;
        var _this = this;
        this.createActor = function() {
            var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(canisterId, idlFactory) {
                var authed;
                return regeneratorRuntime.wrap(function _callee$(_ctx) {
                    while(1)switch(_ctx.prev = _ctx.next){
                        case 0:
                            _this._assertEnv();
                            if (!_this._confirm) {
                                _ctx.next = 9;
                                break;
                            }
                            _ctx.t0 = _this;
                            _ctx.next = 5;
                            return _ms.appendAuth.invoke(_this._cacheKey, _this._wallet, [
                                canisterId
                            ]);
                        case 5:
                            _ctx.t1 = _ctx.sent;
                            authed = _ctx.t0._handleWebViewConnectResponse.call(_ctx.t0, _ctx.t1);
                            if (authed) {
                                _ctx.next = 9;
                                break;
                            }
                            throw new Error("User cancel authorization");
                        case 9:
                            return _ctx.abrupt("return", Actor.createActor(idlFactory, {
                                agent: _this._agent,
                                canisterId: canisterId
                            }));
                        case 10:
                        case "end":
                            return _ctx.stop();
                    }
                }, _callee);
            }));
            return function(canisterId, idlFactory) {
                return _ref.apply(this, arguments);
            };
        }();
        this._injectWindow();
    }
    var _proto = AstroXWebViewHandler.prototype;
    _proto.setCacheKey = function setCacheKey(value) {
        this._cacheKey = value;
        this._storage.set(KEY_ICSTORAGE_CACHEKEY, value);
    };
    _proto.setWallet = function setWallet(value) {
        this._wallet = value;
        this._storage.set(KEY_ICSTORAGE_WALLET, JSON.stringify(_objectSpread({}, value)));
    };
    _proto.setChain = function setChain(value) {
        this._chain = value;
        this._storage.set(KEY_ICSTORAGE_CHAIN, JSON.stringify(value === null || value === void 0 ? void 0 : value.toJSON()));
    };
    _proto.setConfirm = function setConfirm(value) {
        this._confirm = value;
        this._storage.set(KEY_ICSTORAGE_CONFIRM, String(value));
    };
    _proto.setIdentity = function setIdentity(value) {
        this._identity = value;
    };
    _proto.setAgent = function setAgent(value) {
        this._agent = value;
    };
    _proto.setHost = function setHost(host) {
        this._storage.set(KEY_ICSTORAGE_HOST, String(host));
    };
    _proto.setStorage = function setStorage(storage) {
        this._storage = storage;
    };
    _proto.clear = function clear() {
        this._cacheKey = undefined;
        this._confirm = undefined;
        this._chain = undefined;
        this._wallet = undefined;
        this._identity = undefined;
        this._agent = undefined;
        this._storage.remove(KEY_ICSTORAGE_CACHEKEY);
        this._storage.remove(KEY_ICSTORAGE_WALLET);
        this._storage.remove(KEY_ICSTORAGE_CHAIN);
        this._storage.remove(KEY_ICSTORAGE_CONFIRM);
        this._storage.remove(KEY_ICSTORAGE_HOST);
    };
    _proto._injectWindow = function _injectWindow() {
        window.icx = this;
    };
    _proto._initBridge = function _initBridge() {
        var _this = this;
        return _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
            return regeneratorRuntime.wrap(function _callee$(_ctx) {
                while(1)switch(_ctx.prev = _ctx.next){
                    case 0:
                        _ctx.prev = 0;
                        _ctx.next = 3;
                        return _this.fromStorage();
                    case 3:
                        _this._isReady = true;
                        console.log("%cAstroXWebViewBridge%c is ready.", "background: #26d1d1; color: white; padding: 2px 4px; border-radius: 2px", "");
                        _ctx.next = 11;
                        break;
                    case 7:
                        _ctx.prev = 7;
                        _ctx.t0 = _ctx["catch"](0);
                        console.log("AstroXWebViewBridge occurs error:", _ctx.t0);
                        throw _ctx.t0;
                    case 11:
                    case "end":
                        return _ctx.stop();
                }
            }, _callee, null, [
                [
                    0,
                    7
                ]
            ]);
        }))();
    };
    _proto.fromStorage = function fromStorage() {
        var _this = this;
        return _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
            var storage, cacheKey, connected, chainString, chain, identity, walletJson, hostString;
            return regeneratorRuntime.wrap(function _callee$(_ctx) {
                while(1)switch(_ctx.prev = _ctx.next){
                    case 0:
                        storage = new ICStorage("astrox-");
                        _ctx.next = 3;
                        return storage.get(KEY_ICSTORAGE_CACHEKEY);
                    case 3:
                        cacheKey = _ctx.sent;
                        _this.setStorage(storage);
                        if (!cacheKey) {
                            _ctx.next = 38;
                            break;
                        }
                        _ctx.next = 8;
                        return _ms.isConnected.invoke(cacheKey);
                    case 8:
                        connected = _ctx.sent;
                        if (connected) {
                            _ctx.next = 12;
                            break;
                        }
                        _this.clear();
                        return _ctx.abrupt("return");
                    case 12:
                        _ctx.next = 14;
                        return storage.get(KEY_ICSTORAGE_CHAIN);
                    case 14:
                        chainString = _ctx.sent;
                        chain = chainString ? DelegationChain.fromJSON(chainString) : null;
                        if (!(!chain || !isDelegationValid(chain))) {
                            _ctx.next = 19;
                            break;
                        }
                        _this.clear();
                        return _ctx.abrupt("return");
                    case 19:
                        identity = new AstroXIdentity(cacheKey, chain);
                        _ctx.next = 22;
                        return storage.get(KEY_ICSTORAGE_WALLET);
                    case 22:
                        walletJson = _ctx.sent;
                        _ctx.next = 25;
                        return storage.get(KEY_ICSTORAGE_HOST);
                    case 25:
                        hostString = _ctx.sent;
                        _this.setHost(hostString);
                        _this.setCacheKey(cacheKey);
                        _this.setChain(chain);
                        _this.setWallet(walletJson ? JSON.parse(walletJson) : null);
                        _ctx.t0 = _this;
                        _ctx.next = 33;
                        return storage.get(KEY_ICSTORAGE_CONFIRM);
                    case 33:
                        _ctx.t1 = _ctx.sent;
                        _ctx.t2 = _ctx.t1 == "true";
                        _ctx.t0.setConfirm.call(_ctx.t0, _ctx.t2);
                        _this.setIdentity(identity);
                        _this.setAgent(new HttpAgent({
                            identity: identity,
                            host: hostString !== null && hostString !== void 0 ? hostString : window.location.origin
                        }));
                    case 38:
                    case "end":
                        return _ctx.stop();
                }
            }, _callee);
        }))();
    };
    _proto.isReady = function isReady() {
        return !!window.astrox_webview && this._isReady;
    };
    _proto.getDelegation = function getDelegation() {
        return this._chain;
    };
    _proto.getPublicKey = function getPublicKey() {
        var ref;
        return (ref = this._identity) === null || ref === void 0 ? void 0 : ref.getPublicKey();
    };
    _proto.getPrincipal = function getPrincipal() {
        var ref;
        return (ref = this._identity) === null || ref === void 0 ? void 0 : ref.getPrincipal();
    };
    _proto._assertEnv = function _assertEnv() {
        if (!this.isReady()) {
            throw Error("Webview Bridge is not ready");
        }
    };
    _proto.connect = function connect(params) {
        var _this = this;
        return _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
            return regeneratorRuntime.wrap(function _callee$(_ctx) {
                while(1)switch(_ctx.prev = _ctx.next){
                    case 0:
                        _this._assertEnv();
                        if (_this.identity) {
                            _ctx.next = 3;
                            break;
                        }
                        return _ctx.abrupt("return", _this.reconnect(params));
                    case 3:
                        return _ctx.abrupt("return", true);
                    case 4:
                    case "end":
                        return _ctx.stop();
                }
            }, _callee);
        }))();
    };
    _proto.reconnect = function reconnect(params) {
        var _this = this;
        return _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
            var ref, delegationModes, modes, hasNotInclude, result;
            return regeneratorRuntime.wrap(function _callee$(_ctx) {
                while(1)switch(_ctx.prev = _ctx.next){
                    case 0:
                        ;
                        _this._assertEnv();
                        delegationModes = params.delegationModes;
                        if (!(delegationModes && delegationModes.length)) {
                            _ctx.next = 9;
                            break;
                        }
                        modes = [
                            "global",
                            "domain"
                        ];
                        hasNotInclude = delegationModes.some(function(v) {
                            return !modes.includes(v);
                        });
                        if (!hasNotInclude) {
                            _ctx.next = 8;
                            break;
                        }
                        throw new Error("`delegationModes` elements only support `global` and `domain`");
                    case 8:
                        delegationModes = _toConsumableArray(new Set(delegationModes));
                    case 9:
                        _ctx.next = 11;
                        return _ms.connect.invoke(_objectSpreadProps(_objectSpread({}, params), {
                            delegationTargets: (ref = params.delegationTargets) === null || ref === void 0 ? void 0 : ref.filter(function(value) {
                                return typeof value === "string" && value.trim();
                            }),
                            delegationModes: delegationModes
                        }));
                    case 11:
                        result = _ctx.sent;
                        return _ctx.abrupt("return", _this._handleWebViewConnectResponse(result, params.host));
                    case 13:
                    case "end":
                        return _ctx.stop();
                }
            }, _callee);
        }))();
    };
    _proto._handleWebViewConnectResponse = function _handleWebViewConnectResponse(result, host) {
        var authorized = result.authorized, payload = result.payload;
        if (!authorized) {
            return false;
        }
        if (!payload) {
            return true;
        }
        if (!payload.chain) {
            return false;
        }
        var chainObject;
        try {
            chainObject = DelegationChain.fromJSON(payload.chain);
        } catch (error) {
            return false;
        }
        if (isDelegationValid(chainObject)) {
            this.setChain(chainObject);
            this.setCacheKey(payload.cacheKey);
            this.setWallet(payload.wallet);
            this.setIdentity(new AstroXIdentity(this._cacheKey, this._chain));
            this.setConfirm(payload.confirm);
            this.setAgent(new HttpAgent({
                identity: this._identity,
                host: host !== null && host !== void 0 ? host : window.location.origin
            }));
            this.setHost(host !== null && host !== void 0 ? host : window.location.origin);
            return true;
        }
        return false;
    };
    _proto.getSupportedTokenList = function getSupportedTokenList() {
        var _this = this;
        return _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
            return regeneratorRuntime.wrap(function _callee$(_ctx) {
                while(1)switch(_ctx.prev = _ctx.next){
                    case 0:
                        _this._assertEnv();
                        return _ctx.abrupt("return", _ms.supportedStandardList.invoke());
                    case 2:
                    case "end":
                        return _ctx.stop();
                }
            }, _callee);
        }))();
    };
    _proto.isConnected = function isConnected() {
        var _this = this;
        return _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
            return regeneratorRuntime.wrap(function _callee$(_ctx) {
                while(1)switch(_ctx.prev = _ctx.next){
                    case 0:
                        _this._assertEnv();
                        _ctx.t0 = _this.cacheKey;
                        if (!_ctx.t0) {
                            _ctx.next = 6;
                            break;
                        }
                        _ctx.next = 5;
                        return _ms.isConnected.invoke(_this.cacheKey);
                    case 5:
                        _ctx.t0 = _ctx.sent;
                    case 6:
                        return _ctx.abrupt("return", _ctx.t0);
                    case 7:
                    case "end":
                        return _ctx.stop();
                }
            }, _callee);
        }))();
    };
    _proto.disconnect = function disconnect() {
        var _this = this;
        return _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
            return regeneratorRuntime.wrap(function _callee$(_ctx) {
                while(1)switch(_ctx.prev = _ctx.next){
                    case 0:
                        _this._assertEnv();
                        _ctx.t0 = _this.cacheKey;
                        if (!_ctx.t0) {
                            _ctx.next = 5;
                            break;
                        }
                        _ctx.next = 5;
                        return _ms.disconnect.invoke(_this.cacheKey);
                    case 5:
                        _this.clear();
                        return _ctx.abrupt("return", true);
                    case 7:
                    case "end":
                        return _ctx.stop();
                }
            }, _callee);
        }))();
    };
    _proto.signMessage = function signMessage(message) {
        return _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
            return regeneratorRuntime.wrap(function _callee$(_ctx) {
                while(1)switch(_ctx.prev = _ctx.next){
                    case 0:
                        throw new Error("Unsupported api");
                    case 1:
                    case "end":
                        return _ctx.stop();
                }
            }, _callee);
        }))();
    };
    _proto.requestTransfer = function requestTransfer(req) {
        var _this = this;
        return _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
            var rawSendOpts, sendOpts, memo, standard, createdAtTime, txType, success, ref, code, message;
            return regeneratorRuntime.wrap(function _callee$(_ctx) {
                while(1)switch(_ctx.prev = _ctx.next){
                    case 0:
                        _this._assertEnv();
                        if (_this.cacheKey) {
                            _ctx.next = 3;
                            break;
                        }
                        return _ctx.abrupt("return", BridgeErrors.fromErrorCode(BridgeErrors.bridgeIdentityNotFound, TransactionMessageKind.fail));
                    case 3:
                        if (_this._wallet) {
                            _ctx.next = 5;
                            break;
                        }
                        return _ctx.abrupt("return", BridgeErrors.fromErrorCode(BridgeErrors.bridgeWalletNotFound, TransactionMessageKind.fail));
                    case 5:
                        rawSendOpts = req.sendOpts;
                        ;
                        if (!rawSendOpts) {
                            _ctx.next = 18;
                            break;
                        }
                        memo = rawSendOpts.memo;
                        if (!memo) {
                            _ctx.next = 15;
                            break;
                        }
                        standard = req.standard.toUpperCase();
                        if (!(standard === "EXT" && !Array.isArray(memo))) {
                            _ctx.next = 13;
                            break;
                        }
                        throw new Error("`sendOpts.memo` only supports `Array<number>` type when the standard is `EXT`");
                    case 13:
                        if (!(standard === "ICP" && (typeof memo === "undefined" ? "undefined" : _typeof(memo)) !== "bigint")) {
                            _ctx.next = 15;
                            break;
                        }
                        throw new Error("`sendOpts.memo` only supports `bigint` type when the standard is `ICP`");
                    case 15:
                        createdAtTime = rawSendOpts.created_at_time;
                        sendOpts = _objectSpread({}, rawSendOpts);
                        if (createdAtTime) {
                            if (_instanceof(createdAtTime, Date)) {
                                sendOpts.created_at_time = createdAtTime.getTime();
                            }
                        }
                    case 18:
                        _ctx.prev = 18;
                        txType = req.symbol !== undefined ? TransactionType.token : TransactionType.nft;
                        _ctx.next = 22;
                        return _ms.requestTransfer.invoke(_this.cacheKey, _objectSpreadProps(_objectSpread({}, req), {
                            sendOpts: sendOpts
                        }), _this._wallet);
                    case 22:
                        success = _ctx.sent;
                        _ctx.t0 = txType;
                        _ctx.next = _ctx.t0 === TransactionType.token ? 26 : _ctx.t0 === TransactionType.nft ? 27 : 28;
                        break;
                    case 26:
                        return _ctx.abrupt("return", {
                            kind: TransactionMessageKind.success,
                            type: txType,
                            payload: _objectSpreadProps(_objectSpread({}, success), {
                                originPayload: req
                            })
                        });
                    case 27:
                        return _ctx.abrupt("return", {
                            kind: TransactionMessageKind.success,
                            type: txType,
                            payload: {
                                success: true,
                                originPayload: req
                            }
                        });
                    case 28:
                        return _ctx.abrupt("break", 29);
                    case 29:
                        _ctx.next = 35;
                        break;
                    case 31:
                        _ctx.prev = 31;
                        _ctx.t1 = _ctx["catch"](18);
                        ref = JSON.parse(_ctx.t1.message), code = ref.code, message = ref.message;
                        return _ctx.abrupt("return", BridgeErrors.fromErrorCode(code, TransactionMessageKind.fail, message));
                    case 35:
                    case "end":
                        return _ctx.stop();
                }
            }, _callee, null, [
                [
                    18,
                    31
                ]
            ]);
        }))();
    };
    _proto.queryBalance = function queryBalance() {
        var _this = this;
        return _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
            return regeneratorRuntime.wrap(function _callee$(_ctx) {
                while(1)switch(_ctx.prev = _ctx.next){
                    case 0:
                        _this._assertEnv();
                        _ctx.next = 3;
                        return _ms.queryBalance.invoke(_objectSpread({}, _this.wallet));
                    case 3:
                        return _ctx.abrupt("return", _ctx.sent);
                    case 4:
                    case "end":
                        return _ctx.stop();
                }
            }, _callee);
        }))();
    };
    _proto.address = function address() {
        return _objectSpread({}, this.wallet);
    };
    _proto.init = function init() {
        var _this = this;
        return _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
            return regeneratorRuntime.wrap(function _callee$(_ctx) {
                while(1)switch(_ctx.prev = _ctx.next){
                    case 0:
                        _ctx.next = 2;
                        return _this._initBridge();
                    case 2:
                        _this._assertEnv();
                    case 3:
                    case "end":
                        return _ctx.stop();
                }
            }, _callee);
        }))();
    };
    _createClass(AstroXWebViewHandler, [
        {
            key: "cacheKey",
            get: function get() {
                return this._cacheKey;
            }
        },
        {
            key: "wallet",
            get: function get() {
                return this._wallet;
            }
        },
        {
            key: "chain",
            get: function get() {
                return this._chain;
            }
        },
        {
            key: "confirm",
            get: function get() {
                return this._confirm;
            }
        },
        {
            key: "identity",
            get: function get() {
                return this._identity;
            }
        },
        {
            key: "agent",
            get: function get() {
                return this._agent;
            }
        },
        {
            key: "storage",
            get: function get() {
                return this._storage;
            }
        }
    ]);
    return AstroXWebViewHandler;
}();
