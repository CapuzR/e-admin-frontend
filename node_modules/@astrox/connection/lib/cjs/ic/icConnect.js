"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _IC_authClient, _IC_agent, _IC_localLedger, _IC_walletProvider, _IC_signerProvider, _IC_useFrame, _IC_loginOption, _IC_connectOptions;
Object.defineProperty(exports, "__esModule", { value: true });
exports.IC = void 0;
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable @typescript-eslint/no-non-null-assertion */
const agent_1 = require("@dfinity/agent");
const icAuthClient_1 = require("./icAuthClient");
const icStorage_1 = require("./icStorage");
const icWindow_1 = require("./icWindow");
const ledgerConnection_1 = require("../connections/ledgerConnection");
const types_1 = require("../types");
const days = BigInt(1);
const hours = BigInt(24);
const nanoseconds = BigInt(3600000000000);
const WALLET_PROVIDER_DEFAULT = 'https://63k2f-nyaaa-aaaah-aakla-cai.raw.ic0.app';
const WALLET_PROVIDER_ENDPOINT = '#transaction';
const SIGNER_PROVIDER_DEFAULT = 'https://63k2f-nyaaa-aaaah-aakla-cai.raw.ic0.app';
const SIGNER_PROVIDER_ENDPOINT = '#signer';
const FRAME_SETTING = 'height=600, width=800, top=0, right=0, toolbar=no, menubar=no, scrollbars=no, resizable=no, location=no, status=no';
const FRAME_SETTING_PAYMENT = 'height=600, width=480, top=0, right=0, toolbar=no, menubar=no, scrollbars=no, resizable=no, location=no, status=no';
class IC extends icWindow_1.ICWindow {
    constructor(authClient, agent) {
        super();
        _IC_authClient.set(this, void 0);
        _IC_agent.set(this, void 0);
        _IC_localLedger.set(this, void 0);
        _IC_walletProvider.set(this, void 0);
        _IC_signerProvider.set(this, void 0);
        _IC_useFrame.set(this, false); // a local ledger to query balance only
        _IC_loginOption.set(this, void 0);
        _IC_connectOptions.set(this, void 0);
        this.disconnect = async (options = {}) => {
            await this.getAuthClient().logout(options);
        };
        this.queryBalance = async () => {
            var _a;
            if (this.wallet === undefined) {
                throw Error('Wallet address is not found');
            }
            if (__classPrivateFieldGet(this, _IC_localLedger, "f") === undefined) {
                throw Error('Ledger connection failed');
            }
            const result = await ((_a = __classPrivateFieldGet(this, _IC_localLedger, "f")) === null || _a === void 0 ? void 0 : _a.getBalance(this.wallet));
            return result;
        };
        this.handleAuthenticated = async ({ ledgerCanisterId, ledgerHost, }) => {
            const actorResult = await ledgerConnection_1.LedgerConnection.createActor(this.getAuthClient().getDelegationIdentity(), ledgerCanisterId, ledgerHost);
            __classPrivateFieldSet(this, _IC_localLedger, ledgerConnection_1.LedgerConnection.createConnection(this.getAuthClient().getInnerKey(), this.getAuthClient().getDelegationIdentity(), ledgerCanisterId, actorResult.actor, __classPrivateFieldGet(this, _IC_agent, "f")), "f");
        };
        this.createActor = async (idlFactory, canisterId) => {
            if (__classPrivateFieldGet(this, _IC_authClient, "f").getConfirm() === true) {
                await this._appendAuth(canisterId);
            }
            return agent_1.Actor.createActor(idlFactory, {
                agent: __classPrivateFieldGet(this, _IC_agent, "f"),
                canisterId,
            });
        };
        // requestTransfer
        this.requestTransfer = async (options) => {
            var _a;
            console.assert(this.wallet !== undefined, 'wallet address is not found');
            const walletProviderUrl = new URL(((_a = options === null || options === void 0 ? void 0 : options.walletProvider) === null || _a === void 0 ? void 0 : _a.toString()) || __classPrivateFieldGet(this, _IC_walletProvider, "f") || WALLET_PROVIDER_DEFAULT);
            walletProviderUrl.hash = WALLET_PROVIDER_ENDPOINT;
            this._openWindow(walletProviderUrl.toString(), 'icWindow', __classPrivateFieldGet(this, _IC_useFrame, "f") ? FRAME_SETTING_PAYMENT : undefined);
            return new Promise((resolve, reject) => {
                this._eventHandler = this._getEventHandler(walletProviderUrl, resolve, reject, options);
                window.addEventListener('message', this._eventHandler);
            });
        };
        this.signMessage = async (options) => {
            var _a;
            console.assert(this.wallet !== undefined, 'wallet address is not found');
            const signerProviderUrl = new URL(((_a = options === null || options === void 0 ? void 0 : options.signerProvider) === null || _a === void 0 ? void 0 : _a.toString()) || __classPrivateFieldGet(this, _IC_signerProvider, "f") || SIGNER_PROVIDER_DEFAULT);
            signerProviderUrl.hash = SIGNER_PROVIDER_ENDPOINT;
            this._openWindow(signerProviderUrl.toString(), 'icWindow', __classPrivateFieldGet(this, _IC_useFrame, "f") ? FRAME_SETTING_PAYMENT : undefined);
            return new Promise((resolve, reject) => {
                this._eventHandler = this._getSignerHandler(signerProviderUrl, resolve, reject, options);
                window.addEventListener('message', this._eventHandler);
            });
        };
        __classPrivateFieldSet(this, _IC_authClient, authClient, "f");
        __classPrivateFieldSet(this, _IC_agent, agent, "f");
        this.injectWindow();
    }
    static async create(config) {
        var _a, _b, _c;
        const authClient = await icAuthClient_1.AuthClient.create(Object.assign(Object.assign({}, config), { idpWindowOption: config.useFrame === true ? FRAME_SETTING : undefined }));
        const identity = authClient.getIdentity();
        const agent = new agent_1.HttpAgent({ identity });
        const newIC = new this(authClient, agent);
        if (config.dev) {
            await agent.fetchRootKey();
        }
        newIC._setWalletProvider(config === null || config === void 0 ? void 0 : config.walletProviderUrl);
        newIC._setSignerProvider(config === null || config === void 0 ? void 0 : config.signerProviderUrl);
        newIC._setUseFrame(config === null || config === void 0 ? void 0 : config.useFrame);
        if (await newIC.isAuthenticated()) {
            await newIC.handleAuthenticated({
                ledgerCanisterId: (_a = config.ledgerCanisterId) !== null && _a !== void 0 ? _a : 'ryjl3-tyaaa-aaaaa-aaaba-cai',
                ledgerHost: (_b = config.ledgerHost) !== null && _b !== void 0 ? _b : 'https://boundary.ic0.app/',
            });
            await ((_c = config === null || config === void 0 ? void 0 : config.onAuthenticated) === null || _c === void 0 ? void 0 : _c.call(config, newIC));
        }
        return newIC;
    }
    async connect(connectOptions) {
        var _a;
        const provider = (_a = connectOptions === null || connectOptions === void 0 ? void 0 : connectOptions.identityProvider) !== null && _a !== void 0 ? _a : icStorage_1.IDENTITY_PROVIDER_DEFAULT;
        __classPrivateFieldSet(this, _IC_connectOptions, connectOptions, "f");
        await new Promise((resolve, reject) => {
            var _a, _b;
            __classPrivateFieldSet(this, _IC_loginOption, {
                identityProvider: provider,
                // Maximum authorization expiration is 8 days
                maxTimeToLive: (_a = connectOptions === null || connectOptions === void 0 ? void 0 : connectOptions.maxTimeToLive) !== null && _a !== void 0 ? _a : days * hours * nanoseconds,
                permissions: (_b = connectOptions === null || connectOptions === void 0 ? void 0 : connectOptions.permissions) !== null && _b !== void 0 ? _b : [types_1.PermissionsType.identity],
                delegationTargets: connectOptions === null || connectOptions === void 0 ? void 0 : connectOptions.delegationTargets,
            }, "f");
            this.getAuthClient().login(Object.assign(Object.assign({}, __classPrivateFieldGet(this, _IC_loginOption, "f")), { onSuccess: async () => {
                    var _a, _b, _c, _d;
                    await this.handleAuthenticated({
                        ledgerCanisterId: connectOptions.ledgerCanisterId,
                        ledgerHost: (_a = connectOptions.ledgerHost) !== null && _a !== void 0 ? _a : 'https://boundary.ic0.app/',
                    });
                    (_c = (await ((_b = connectOptions === null || connectOptions === void 0 ? void 0 : connectOptions.onSuccess) === null || _b === void 0 ? void 0 : _b.call(connectOptions)))) !== null && _c !== void 0 ? _c : (await ((_d = connectOptions === null || connectOptions === void 0 ? void 0 : connectOptions.onAuthenticated) === null || _d === void 0 ? void 0 : _d.call(connectOptions, this)));
                    resolve(undefined);
                }, onError: this.handleError }));
        });
        return this;
    }
    async isAuthenticated() {
        const result = await __classPrivateFieldGet(this, _IC_authClient, "f").isAuthenticated();
        return result;
    }
    get identity() {
        return __classPrivateFieldGet(this, _IC_authClient, "f").getIdentity();
    }
    get principal() {
        return this.identity.getPrincipal();
    }
    get wallet() {
        return __classPrivateFieldGet(this, _IC_authClient, "f").wallet;
    }
    get delegationTargets() {
        return __classPrivateFieldGet(this, _IC_authClient, "f").getDelegateTargets();
    }
    _setWalletProvider(provider) {
        __classPrivateFieldSet(this, _IC_walletProvider, provider, "f");
    }
    _setSignerProvider(provider) {
        __classPrivateFieldSet(this, _IC_signerProvider, provider, "f");
    }
    _setUseFrame(useFrame) {
        __classPrivateFieldSet(this, _IC_useFrame, useFrame, "f");
    }
    getAuthClient() {
        return __classPrivateFieldGet(this, _IC_authClient, "f");
    }
    injectWindow() {
        if (window.ic !== undefined) {
            window.ic.astrox = this;
        }
        else {
            window.ic = { astrox: this };
        }
    }
    async _appendAuth(canisterId) {
        const currentTargets = __classPrivateFieldGet(this, _IC_authClient, "f").getDelegateTargets();
        if (currentTargets.includes(canisterId)) {
            return this;
        }
        else {
            const newTargets = [...currentTargets, canisterId];
            await new Promise((resolve, reject) => {
                this.getAuthClient().login(Object.assign(Object.assign({}, __classPrivateFieldGet(this, _IC_loginOption, "f")), { authType: 'authorize-append', delegationTargets: newTargets, onSuccess: async () => {
                        var _a, _b, _c, _d, _e, _f, _g, _h;
                        await this.handleAuthenticated({
                            ledgerCanisterId: (_a = __classPrivateFieldGet(this, _IC_connectOptions, "f")) === null || _a === void 0 ? void 0 : _a.ledgerCanisterId,
                            ledgerHost: (_c = (_b = __classPrivateFieldGet(this, _IC_connectOptions, "f")) === null || _b === void 0 ? void 0 : _b.ledgerHost) !== null && _c !== void 0 ? _c : 'https://boundary.ic0.app/',
                        });
                        (_f = (await ((_e = (_d = __classPrivateFieldGet(this, _IC_connectOptions, "f")) === null || _d === void 0 ? void 0 : _d.onSuccess) === null || _e === void 0 ? void 0 : _e.call(_d)))) !== null && _f !== void 0 ? _f : (await ((_h = (_g = __classPrivateFieldGet(this, _IC_connectOptions, "f")) === null || _g === void 0 ? void 0 : _g.onAuthenticated) === null || _h === void 0 ? void 0 : _h.call(_g, this)));
                        resolve(undefined);
                    }, onError: this.handleError }));
            });
            return this;
        }
    }
    handleError(error) {
        throw new Error(error);
    }
    _getSignerHandler(walletProviderUrl, resolve, reject, options) {
        return async (event) => {
            var _a, _b, _c, _d, _e;
            if (event.origin !== walletProviderUrl.origin) {
                return;
            }
            const message = event.data;
            switch (message.kind) {
                case types_1.SignerMessageKind.ready: {
                    // IDP is ready. Send a message to request authorization.
                    const request = {
                        kind: types_1.SignerMessageKind.client,
                        from: (_a = options.from) !== null && _a !== void 0 ? _a : this.wallet,
                        message: options.message,
                        maxTimeout: (_b = options.maxTimeout) !== null && _b !== void 0 ? _b : 90,
                        successTimeout: (_c = options.successTimeout) !== null && _c !== void 0 ? _c : 10,
                    };
                    (_d = this._window) === null || _d === void 0 ? void 0 : _d.postMessage(request, walletProviderUrl.origin);
                    break;
                }
                case types_1.SignerMessageKind.success:
                    // Create the delegation chain and store it.
                    try {
                        resolve(this._handleSuccess(message, options.onSuccess, (_e = options.successTimeout) !== null && _e !== void 0 ? _e : 10));
                    }
                    catch (err) {
                        reject(this._handleFailure(err.message, options.onError));
                    }
                    break;
                case types_1.SignerMessageKind.fail:
                    reject(this._handleFailure(message.text, options.onError));
                    break;
                default:
                    break;
            }
        };
    }
    _getEventHandler(walletProviderUrl, resolve, reject, options) {
        return async (event) => {
            var _a, _b, _c, _d, _e;
            if (event.origin !== walletProviderUrl.origin) {
                return;
            }
            const message = event.data;
            switch (message.kind) {
                case types_1.TransactionMessageKind.ready: {
                    // IDP is ready. Send a message to request authorization.
                    const request = {
                        kind: types_1.TransactionMessageKind.client,
                        from: (_a = options.from) !== null && _a !== void 0 ? _a : this.wallet,
                        to: options.to,
                        amount: options.amount,
                        sendOpts: options.sendOpts,
                        maxTimeout: (_b = options.maxTimeout) !== null && _b !== void 0 ? _b : 90,
                        successTimeout: (_c = options.successTimeout) !== null && _c !== void 0 ? _c : 10,
                    };
                    (_d = this._window) === null || _d === void 0 ? void 0 : _d.postMessage(request, walletProviderUrl.origin);
                    break;
                }
                case types_1.TransactionMessageKind.success:
                    // Create the delegation chain and store it.
                    try {
                        resolve(this._handleSuccess(message, options.onSuccess, (_e = options.successTimeout) !== null && _e !== void 0 ? _e : 10));
                    }
                    catch (err) {
                        reject(this._handleFailure(err.message, options.onError));
                    }
                    break;
                case types_1.TransactionMessageKind.fail:
                    reject(this._handleFailure(message.text, options.onError));
                    break;
                default:
                    break;
            }
        };
    }
    _handleFailure(errorMessage, onError) {
        this._remove();
        onError === null || onError === void 0 ? void 0 : onError(errorMessage);
        return errorMessage;
    }
    _handleSuccess(value, onSuccess, delay) {
        if (delay) {
            setTimeout(() => this._remove(), delay * 1000);
        }
        else {
            this._remove();
        }
        onSuccess === null || onSuccess === void 0 ? void 0 : onSuccess(value);
        return value;
    }
}
exports.IC = IC;
_IC_authClient = new WeakMap(), _IC_agent = new WeakMap(), _IC_localLedger = new WeakMap(), _IC_walletProvider = new WeakMap(), _IC_signerProvider = new WeakMap(), _IC_useFrame = new WeakMap(), _IC_loginOption = new WeakMap(), _IC_connectOptions = new WeakMap();
//# sourceMappingURL=icConnect.js.map