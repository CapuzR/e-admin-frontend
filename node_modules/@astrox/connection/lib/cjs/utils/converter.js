"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAddressType = exports.AddressType = exports.validateCanisterId = exports.validatePrincipalId = exports.validateAccountId = exports.balanceToString = exports.balanceFromString = exports.parseBalance = exports.formatAssetBySymbol = exports.getDecimalFromSymbol = exports.TokenSymbol = exports.E8S_PER_ICP = exports.calculateCrc32 = exports.stringToAccountIdentifier = exports.principalToSubAccount = exports.principalToAccountIdentifier = exports.accountIdentifierFromBytes = exports.accountIdentifierToBytes = exports.fromSubAccountId = exports.toSubAccountId = exports.asciiStringToByteArray = exports.numberToArrayBuffer = exports.arrayBufferToNumber = exports.arrayOfNumberToArrayBuffer = exports.arrayOfNumberToUint8Array = exports.arrayBufferToArrayOfNumber = exports.bigIntToUint8Array = exports.uint8ArrayToBigInt = void 0;
/* eslint-disable no-useless-catch */
const principal_1 = require("@dfinity/principal");
const js_sha256_1 = require("js-sha256");
const buffer_1 = require("buffer");
const crc_1 = __importDefault(require("crc"));
const constants_1 = require("./constants");
const uint8ArrayToBigInt = (array) => {
    const view = new DataView(array.buffer, array.byteOffset, array.byteLength);
    if (typeof view.getBigUint64 === 'function') {
        return view.getBigUint64(0);
    }
    else {
        const high = BigInt(view.getUint32(0));
        const low = BigInt(view.getUint32(4));
        return (high << BigInt(32)) + low;
    }
};
exports.uint8ArrayToBigInt = uint8ArrayToBigInt;
const TWO_TO_THE_32 = BigInt(1) << BigInt(32);
const bigIntToUint8Array = (value) => {
    const array = new Uint8Array(8);
    const view = new DataView(array.buffer, array.byteOffset, array.byteLength);
    if (typeof view.setBigUint64 === 'function') {
        view.setBigUint64(0, value);
    }
    else {
        view.setUint32(0, Number(value >> BigInt(32)));
        view.setUint32(4, Number(value % TWO_TO_THE_32));
    }
    return array;
};
exports.bigIntToUint8Array = bigIntToUint8Array;
const arrayBufferToArrayOfNumber = (buffer) => {
    const typedArray = new Uint8Array(buffer);
    return Array.from(typedArray);
};
exports.arrayBufferToArrayOfNumber = arrayBufferToArrayOfNumber;
const arrayOfNumberToUint8Array = (numbers) => {
    return new Uint8Array(numbers);
};
exports.arrayOfNumberToUint8Array = arrayOfNumberToUint8Array;
const arrayOfNumberToArrayBuffer = (numbers) => {
    return (0, exports.arrayOfNumberToUint8Array)(numbers).buffer;
};
exports.arrayOfNumberToArrayBuffer = arrayOfNumberToArrayBuffer;
const arrayBufferToNumber = (buffer) => {
    const view = new DataView(buffer);
    return view.getUint32(view.byteLength - 4);
};
exports.arrayBufferToNumber = arrayBufferToNumber;
const numberToArrayBuffer = (value, byteLength) => {
    const buffer = new ArrayBuffer(byteLength);
    new DataView(buffer).setUint32(byteLength - 4, value);
    return buffer;
};
exports.numberToArrayBuffer = numberToArrayBuffer;
const asciiStringToByteArray = (text) => {
    return Array.from(text).map(c => c.charCodeAt(0));
};
exports.asciiStringToByteArray = asciiStringToByteArray;
const toSubAccountId = (subAccount) => {
    const bytes = (0, exports.arrayOfNumberToArrayBuffer)(subAccount);
    return (0, exports.arrayBufferToNumber)(bytes);
};
exports.toSubAccountId = toSubAccountId;
const fromSubAccountId = (subAccountId) => {
    const buffer = (0, exports.numberToArrayBuffer)(subAccountId, constants_1.SUB_ACCOUNT_BYTE_LENGTH);
    return (0, exports.arrayBufferToArrayOfNumber)(buffer);
};
exports.fromSubAccountId = fromSubAccountId;
const accountIdentifierToBytes = (accountIdentifier) => {
    return Uint8Array.from(buffer_1.Buffer.from(accountIdentifier, 'hex')).subarray(4);
};
exports.accountIdentifierToBytes = accountIdentifierToBytes;
const accountIdentifierFromBytes = (accountIdentifier) => {
    return buffer_1.Buffer.from(accountIdentifier).toString('hex');
};
exports.accountIdentifierFromBytes = accountIdentifierFromBytes;
const principalToAccountIdentifier = (principal, subAccount) => {
    // Hash (sha224) the principal, the subAccount and some padding
    const padding = (0, exports.asciiStringToByteArray)('\x0Aaccount-id');
    const shaObj = js_sha256_1.sha224.create();
    shaObj.update([...padding, ...principal.toUint8Array(), ...(subAccount !== null && subAccount !== void 0 ? subAccount : Array(32).fill(0))]);
    const hash = new Uint8Array(shaObj.array());
    // Prepend the checksum of the hash and convert to a hex string
    const checksum = (0, exports.calculateCrc32)(hash);
    const bytes = new Uint8Array([...checksum, ...hash]);
    return toHexString(bytes);
};
exports.principalToAccountIdentifier = principalToAccountIdentifier;
const principalToSubAccount = (principal) => {
    const bytes = principal.toUint8Array();
    const subAccount = new Uint8Array(32);
    subAccount[0] = bytes.length;
    subAccount.set(bytes, 1);
    return subAccount;
};
exports.principalToSubAccount = principalToSubAccount;
const stringToAccountIdentifier = (str) => {
    try {
        if (str.length === 64) {
            return str;
        }
        if (str.length === 63) {
            return (0, exports.principalToAccountIdentifier)(principal_1.Principal.fromText(str));
        }
        return undefined;
    }
    catch (error) {
        return undefined;
    }
};
exports.stringToAccountIdentifier = stringToAccountIdentifier;
const toHexString = (bytes) => bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');
// 4 bytes
const calculateCrc32 = (bytes) => {
    const checksumArrayBuf = new ArrayBuffer(4);
    const view = new DataView(checksumArrayBuf);
    view.setUint32(0, crc_1.default.crc32(buffer_1.Buffer.from(bytes)), false);
    return buffer_1.Buffer.from(checksumArrayBuf);
};
exports.calculateCrc32 = calculateCrc32;
exports.E8S_PER_ICP = 100000000;
var TokenSymbol;
(function (TokenSymbol) {
    TokenSymbol["ICP"] = "ICP";
})(TokenSymbol = exports.TokenSymbol || (exports.TokenSymbol = {}));
const getDecimalFromSymbol = (sym) => {
    switch (sym) {
        case TokenSymbol.ICP:
            return 8;
        default:
            return 8;
    }
};
exports.getDecimalFromSymbol = getDecimalFromSymbol;
const formatAssetBySymbol = (_amount, symbol) => {
    const balanceString = (0, exports.balanceToString)(_amount, (0, exports.getDecimalFromSymbol)(symbol));
    const amount = Number(balanceString.total);
    const tokenMap = [
        {
            ICP: {
                amount: amount,
                balanceString,
                symbol: 'ICP',
            },
        },
    ];
    const found = tokenMap.find((v) => v[symbol] !== undefined);
    return found === null || found === void 0 ? void 0 : found[symbol];
};
exports.formatAssetBySymbol = formatAssetBySymbol;
const parseBalance = (balance) => {
    return (parseInt(balance.value, 10) / 10 ** balance.decimals).toString();
};
exports.parseBalance = parseBalance;
const balanceFromString = (balance, decimal = 8) => {
    const list = balance.split('.');
    const aboveZero = list[0];
    const aboveZeroBigInt = BigInt(aboveZero) * BigInt(1 * 10 ** decimal);
    let belowZeroBigInt = BigInt(0);
    const belowZero = list[1];
    if (belowZero !== undefined) {
        belowZeroBigInt = BigInt(belowZero.substring(0, decimal).padEnd(decimal, '0'));
    }
    return aboveZeroBigInt + belowZeroBigInt;
};
exports.balanceFromString = balanceFromString;
const balanceToString = (balance, decimal = 8) => {
    const balanceString = balance.toString(10);
    const balanceStringLength = balanceString.length;
    let aboveZero = '0';
    let belowZero = '0'.padEnd(decimal, '0');
    if (balanceStringLength > decimal) {
        belowZero = balanceString.substring(balanceStringLength - decimal, balanceStringLength);
        aboveZero = balanceString.substring(0, balanceStringLength - decimal);
    }
    else {
        belowZero = balanceString.padStart(decimal, '0');
    }
    const formatAboveZero = String(aboveZero).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
    return { total: aboveZero + '.' + belowZero, aboveZero, belowZero, formatAboveZero };
};
exports.balanceToString = balanceToString;
const validateAccountId = (text) => text.length === 64 && constants_1.ALPHANUM_REGEX.test(text);
exports.validateAccountId = validateAccountId;
const validatePrincipalId = (text) => {
    try {
        return text === principal_1.Principal.fromText(text).toString();
    }
    catch (e) {
        return false;
    }
};
exports.validatePrincipalId = validatePrincipalId;
const validateCanisterId = (text) => {
    try {
        return text.length <= constants_1.CANISTER_MAX_LENGTH && (0, exports.validatePrincipalId)(text);
    }
    catch (e) {
        return false;
    }
};
exports.validateCanisterId = validateCanisterId;
var AddressType;
(function (AddressType) {
    AddressType["PRINCIPAL"] = "principal";
    AddressType["ACCOUNT"] = "accountId";
    AddressType["CANISTER"] = "canister";
    AddressType["ERC20"] = "erc20";
    AddressType["INVALID"] = "invalid";
})(AddressType = exports.AddressType || (exports.AddressType = {}));
const getAddressType = (text) => {
    try {
        if ((0, exports.validateAccountId)(text)) {
            return AddressType.ACCOUNT;
        }
        else if ((0, exports.validatePrincipalId)(text)) {
            return AddressType.PRINCIPAL;
        }
        else if ((0, exports.validateCanisterId)(text)) {
            return AddressType.CANISTER;
        }
        return AddressType.INVALID;
    }
    catch (error) {
        throw error;
    }
};
exports.getAddressType = getAddressType;
//# sourceMappingURL=converter.js.map