/* eslint-disable @typescript-eslint/no-non-null-assertion */ /* eslint-disable @typescript-eslint/no-explicit-any */ /* eslint-disable @typescript-eslint/no-non-null-asserted-optional-chain */ function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _asyncToGenerator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
        }
        ownKeys.forEach(function(key) {
            _defineProperty(target, key, source[key]);
        });
    }
    return target;
}
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) {
            symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
        }
        keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpreadProps(target, source) {
    source = source != null ? source : {};
    if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
        ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
import regeneratorRuntime from "regenerator-runtime";
import { AnonymousIdentity } from "@dfinity/agent";
import { isDelegationValid } from "@dfinity/authentication";
import { Principal } from "@dfinity/principal";
import { Delegation, DelegationChain, DelegationIdentity, Ed25519KeyIdentity } from "@dfinity/identity";
import { PermissionsType } from "../types";
import { IDENTITY_PROVIDER_DEFAULT, IDENTITY_PROVIDER_ENDPOINT, KEY_ICSTORAGE_DELEGATION, KEY_ICSTORAGE_KEY, KEY_ICSTORAGE_WALLET, ICStorage, _deleteStorage, KEY_DELEGATION_PARAMS } from "./icStorage";
export var AuthClient = /*#__PURE__*/ function() {
    "use strict";
    function AuthClient(_identity, _key, _chain, _storage, _wallet, _appId, _delegationIdentity) {
        var _delegationTargets = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : [], _lastRequest = arguments.length > 8 ? arguments[8] : void 0, _confirm = arguments.length > 9 ? arguments[9] : void 0, _idpWindowOption = arguments.length > 10 ? arguments[10] : void 0, _idpWindow = arguments.length > 11 ? arguments[11] : void 0, _eventHandler = arguments.length > 12 ? arguments[12] : void 0;
        _classCallCheck(this, AuthClient);
        this._identity = _identity;
        this._key = _key;
        this._chain = _chain;
        this._storage = _storage;
        this._wallet = _wallet;
        this._appId = _appId;
        this._delegationIdentity = _delegationIdentity;
        this._delegationTargets = _delegationTargets;
        this._lastRequest = _lastRequest;
        this._confirm = _confirm;
        this._idpWindowOption = _idpWindowOption;
        this._idpWindow = _idpWindow;
        this._eventHandler = _eventHandler;
    }
    var _proto = AuthClient.prototype;
    _proto._handleSuccess = function _handleSuccess(message, onSuccess) {
        var _this = this;
        return _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
            var ref, idDelegations, idDelegationChain, iiDelegations, iiDelegationChain, key;
            return regeneratorRuntime.wrap(function _callee$(_ctx) {
                while(1)switch(_ctx.prev = _ctx.next){
                    case 0:
                        ;
                        // console.log(message["identity"]);
                        if (message["identity"] !== undefined) {
                            idDelegations = message["identity"].delegations.map(function(signedDelegation) {
                                var ref;
                                var targets = signedDelegation.delegation.targets && signedDelegation.delegation.targets.length > 0 ? (ref = signedDelegation.delegation.targets) === null || ref === void 0 ? void 0 : ref.map(function(t) {
                                    return Principal.fromText(t);
                                }) : undefined;
                                if (targets) {
                                    _this._delegationTargets = _toConsumableArray(new Set(_this._delegationTargets.concat(targets.map(function(e) {
                                        return e.toText();
                                    }))));
                                }
                                return {
                                    delegation: new Delegation(signedDelegation.delegation.pubkey.buffer, signedDelegation.delegation.expiration, targets),
                                    signature: signedDelegation.signature.buffer
                                };
                            });
                            idDelegationChain = DelegationChain.fromDelegations(idDelegations, message["identity"].userPublicKey.buffer);
                            _this._chain = idDelegationChain;
                            _this._wallet = message["wallet"];
                            _this._confirm = message["confirm"];
                        } else {
                            iiDelegations = message.delegations.map(function(signedDelegation) {
                                var ref;
                                var targets = signedDelegation.delegation.targets && signedDelegation.delegation.targets.length > 0 ? (ref = signedDelegation.delegation.targets) === null || ref === void 0 ? void 0 : ref.map(function(t) {
                                    return Principal.fromText(t);
                                }) : undefined;
                                if (targets) {
                                    _this._delegationTargets = _toConsumableArray(new Set(_this._delegationTargets.concat(targets.map(function(e) {
                                        return e.toText();
                                    }))));
                                }
                                return {
                                    delegation: new Delegation(signedDelegation.delegation.pubkey.buffer, signedDelegation.delegation.expiration, targets),
                                    signature: signedDelegation.signature.buffer
                                };
                            });
                            iiDelegationChain = DelegationChain.fromDelegations(iiDelegations, message.userPublicKey.buffer);
                            _this._chain = iiDelegationChain;
                        }
                        key = _this._key;
                        if (key) {
                            _ctx.next = 5;
                            break;
                        }
                        return _ctx.abrupt("return", _this);
                    case 5:
                        _this._delegationIdentity = DelegationIdentity.fromDelegation(key, _this._chain);
                        _this._identity = _this._delegationIdentity;
                        (ref = _this._idpWindow) === null || ref === void 0 ? void 0 : ref.close();
                        _ctx.next = 10;
                        return onSuccess === null || onSuccess === void 0 ? void 0 : onSuccess();
                    case 10:
                        _this._removeEventListener();
                        return _ctx.abrupt("return", _this);
                    case 12:
                    case "end":
                        return _ctx.stop();
                }
            }, _callee);
        }))();
    };
    _proto.getIdentity = function getIdentity() {
        return this._identity;
    };
    _proto.getLastRequest = function getLastRequest() {
        return this._lastRequest;
    };
    _proto.getDelegationIdentity = function getDelegationIdentity() {
        return this._delegationIdentity;
    };
    _proto.getInnerKey = function getInnerKey() {
        return this._key;
    };
    _proto.getDelegationChain = function getDelegationChain() {
        return this._chain;
    };
    _proto.getConfirm = function getConfirm() {
        return this._confirm;
    };
    _proto.setWallet = function setWallet(data) {
        this._wallet = data;
    };
    _proto.getDelegateTargets = function getDelegateTargets() {
        return this._delegationTargets;
    };
    _proto.setDelegationTargets = function setDelegationTargets(targets) {
        this._delegationTargets = _toConsumableArray(new Set(this._delegationTargets.concat(targets)));
    };
    _proto.isAuthenticated = function isAuthenticated() {
        var _this = this;
        return _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
            return regeneratorRuntime.wrap(function _callee$(_ctx) {
                while(1)switch(_ctx.prev = _ctx.next){
                    case 0:
                        return _ctx.abrupt("return", !_this.getIdentity().getPrincipal().isAnonymous() && _this._chain !== null);
                    case 1:
                    case "end":
                        return _ctx.stop();
                }
            }, _callee);
        }))();
    };
    _proto.login = function login(options) {
        var _this = this;
        return _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
            var ref, // If `login` has been called previously, then close/remove any previous windows
            // and event listeners.
            ref1, key, identityProviderUrl, ref2;
            return regeneratorRuntime.wrap(function _callee$(_ctx) {
                while(1)switch(_ctx.prev = _ctx.next){
                    case 0:
                        ;
                        key = _this._key;
                        if (key) {
                            _ctx.next = 7;
                            break;
                        }
                        // Create a new key (whether or not one was in storage).
                        key = Ed25519KeyIdentity.generate();
                        _this._key = key;
                        _ctx.next = 7;
                        return _this._storage.set(KEY_ICSTORAGE_KEY, JSON.stringify(key));
                    case 7:
                        identityProviderUrl = new URL((options === null || options === void 0 ? void 0 : (ref = options.identityProvider) === null || ref === void 0 ? void 0 : ref.toString()) || IDENTITY_PROVIDER_DEFAULT);
                        // Set the correct hash if it isn't already set.
                        identityProviderUrl.hash = IDENTITY_PROVIDER_ENDPOINT;
                        (ref1 = _this._idpWindow) === null || ref1 === void 0 ? void 0 : ref1.close();
                        _this._removeEventListener();
                        ;
                        // Open a new window with the IDP provider.
                        _this._idpWindow = (ref2 = window.open(identityProviderUrl.toString(), "idpWindow", _this._idpWindowOption)) !== null && ref2 !== void 0 ? ref2 : undefined;
                        return _ctx.abrupt("return", new Promise(function(resolve, reject) {
                            _this._eventHandler = _this._getEventHandler(identityProviderUrl, resolve, reject, options);
                            window.addEventListener("message", _this._eventHandler);
                        }));
                    case 14:
                    case "end":
                        return _ctx.stop();
                }
            }, _callee);
        }))();
    };
    _proto._getEventHandler = function _getEventHandler(identityProviderUrl, resolve, reject, options) {
        var _this = this;
        return function() {
            var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(event) {
                var message, ref, ref1, ref2, ref3, ref4, ref5, request, ref6, params;
                return regeneratorRuntime.wrap(function _callee$(_ctx) {
                    while(1)switch(_ctx.prev = _ctx.next){
                        case 0:
                            if (!(event.origin !== identityProviderUrl.origin)) {
                                _ctx.next = 2;
                                break;
                            }
                            return _ctx.abrupt("return");
                        case 2:
                            message = event.data;
                            _ctx.t0 = message.kind;
                            _ctx.next = _ctx.t0 === "authorize-ready" ? 6 : _ctx.t0 === "authorize-client-success" ? 12 : _ctx.t0 === "authorize-client-failure" ? 35 : 37;
                            break;
                        case 6:
                            ;
                            ;
                            request = (options === null || options === void 0 ? void 0 : options.authType) === "authorize-append" && _this._lastRequest ? _objectSpreadProps(_objectSpread({}, _this._lastRequest), {
                                delegationTargets: (ref3 = options === null || options === void 0 ? void 0 : options.delegationTargets) !== null && ref3 !== void 0 ? ref3 : [],
                                sessionPublicKey: new Uint8Array((ref = _this._key) === null || ref === void 0 ? void 0 : ref.getPublicKey().toDer()),
                                kind: "authorize-append"
                            }) : {
                                kind: "authorize-client",
                                sessionPublicKey: new Uint8Array((ref1 = _this._key) === null || ref1 === void 0 ? void 0 : ref1.getPublicKey().toDer()),
                                maxTimeToLive: options === null || options === void 0 ? void 0 : options.maxTimeToLive,
                                permissions: (ref4 = options === null || options === void 0 ? void 0 : options.permissions) !== null && ref4 !== void 0 ? ref4 : [
                                    PermissionsType.identity
                                ],
                                delegationTargets: (ref5 = options === null || options === void 0 ? void 0 : options.delegationTargets) !== null && ref5 !== void 0 ? ref5 : [],
                                delegationModes: options === null || options === void 0 ? void 0 : options.delegationModes,
                                appId: _this._appId,
                                noUnify: options === null || options === void 0 ? void 0 : options.noUnify
                            };
                            _this._lastRequest = request;
                            (ref2 = _this._idpWindow) === null || ref2 === void 0 ? void 0 : ref2.postMessage(request, identityProviderUrl.origin);
                            return _ctx.abrupt("break", 38);
                        case 12:
                            _ctx.prev = 12;
                            _ctx.t1 = resolve;
                            _ctx.next = 16;
                            return _this._handleSuccess(message, options === null || options === void 0 ? void 0 : options.onSuccess);
                        case 16:
                            _ctx.t2 = _ctx.sent;
                            (0, _ctx.t1)(_ctx.t2);
                            if (!_this._chain) {
                                _ctx.next = 21;
                                break;
                            }
                            _ctx.next = 21;
                            return _this._storage.set(KEY_ICSTORAGE_DELEGATION, JSON.stringify(_this._chain.toJSON()));
                        case 21:
                            if (!(_this._wallet !== undefined)) {
                                _ctx.next = 24;
                                break;
                            }
                            _ctx.next = 24;
                            return _this._storage.set(KEY_ICSTORAGE_WALLET, JSON.stringify(_this._wallet));
                        case 24:
                            if (!(_this._lastRequest !== undefined)) {
                                _ctx.next = 29;
                                break;
                            }
                            ;
                            params = {
                                lastRequest: _objectSpreadProps(_objectSpread({}, _this._lastRequest), {
                                    maxTimeToLive: (ref6 = _this._lastRequest.maxTimeToLive) === null || ref6 === void 0 ? void 0 : ref6.toString()
                                }),
                                confirm: _this._confirm
                            };
                            _ctx.next = 29;
                            return _this._storage.set(KEY_DELEGATION_PARAMS, JSON.stringify(params));
                        case 29:
                            _ctx.next = 34;
                            break;
                        case 31:
                            _ctx.prev = 31;
                            _ctx.t3 = _ctx["catch"](12);
                            reject(_this._handleFailure(_ctx.t3.message, options === null || options === void 0 ? void 0 : options.onError));
                        case 34:
                            return _ctx.abrupt("break", 38);
                        case 35:
                            reject(_this._handleFailure(message.text, options === null || options === void 0 ? void 0 : options.onError));
                            return _ctx.abrupt("break", 38);
                        case 37:
                            return _ctx.abrupt("break", 38);
                        case 38:
                        case "end":
                            return _ctx.stop();
                    }
                }, _callee, null, [
                    [
                        12,
                        31
                    ]
                ]);
            }));
            return function(event) {
                return _ref.apply(this, arguments);
            };
        }();
    };
    _proto._handleFailure = function _handleFailure(errorMessage, onError) {
        var ref;
        (ref = this._idpWindow) === null || ref === void 0 ? void 0 : ref.close();
        onError === null || onError === void 0 ? void 0 : onError(errorMessage);
        this._removeEventListener();
        return errorMessage;
    };
    _proto._removeEventListener = function _removeEventListener() {
        if (this._eventHandler) {
            window.removeEventListener("message", this._eventHandler);
        }
        this._eventHandler = undefined;
    };
    _proto.logout = function logout() {
        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var _this = this;
        return _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
            return regeneratorRuntime.wrap(function _callee$(_ctx) {
                while(1)switch(_ctx.prev = _ctx.next){
                    case 0:
                        _deleteStorage(_this._storage);
                        // Reset this auth client to a non-authenticated state.
                        _this._identity = new AnonymousIdentity();
                        _this._key = null;
                        _this._chain = null;
                        _this._delegationTargets = [];
                        _this._wallet = undefined;
                        _this._delegationIdentity = undefined;
                        _this._lastRequest = undefined;
                        _this._confirm = undefined;
                        if (options.returnTo) {
                            try {
                                window.history.pushState({}, "", options.returnTo);
                            } catch (e) {
                                window.location.href = options.returnTo;
                            }
                        }
                    case 10:
                    case "end":
                        return _ctx.stop();
                }
            }, _callee);
        }))();
    };
    AuthClient.create = function create() {
        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
            appId: ""
        };
        var _this = this;
        return _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
            var _storage, storage, key, maybeIdentityStorage, identity, chain, wallet, delegationTargets, lastRequest, confirm, delegationIdentity, chainStorage, walletString, delegationParams, delegationParamsString, ret;
            return regeneratorRuntime.wrap(function _callee$(_ctx) {
                while(1)switch(_ctx.prev = _ctx.next){
                    case 0:
                        ;
                        storage = (_storage = options.storage) !== null && _storage !== void 0 ? _storage : new ICStorage("astrox-");
                        key = null;
                        if (!options.identity) {
                            _ctx.next = 7;
                            break;
                        }
                        {
                            key = options.identity;
                        }
                        _ctx.next = 11;
                        break;
                    case 7:
                        _ctx.next = 9;
                        return storage.get(KEY_ICSTORAGE_KEY);
                    case 9:
                        maybeIdentityStorage = _ctx.sent;
                        if (maybeIdentityStorage) {
                            try {
                                key = Ed25519KeyIdentity.fromJSON(maybeIdentityStorage);
                            } catch (e) {
                            // Ignore this, this means that the ICStorage value isn't a valid Ed25519KeyIdentity
                            // serialization.
                            }
                        }
                    case 11:
                        identity = new AnonymousIdentity();
                        chain = null;
                        ;
                        delegationTargets = [];
                        lastRequest = undefined;
                        confirm = true;
                        delegationIdentity = undefined;
                        if (!key) {
                            _ctx.next = 45;
                            break;
                        }
                        _ctx.prev = 19;
                        _ctx.next = 22;
                        return storage.get(KEY_ICSTORAGE_DELEGATION);
                    case 22:
                        chainStorage = _ctx.sent;
                        _ctx.next = 25;
                        return storage.get(KEY_ICSTORAGE_WALLET);
                    case 25:
                        walletString = _ctx.sent;
                        if (walletString) {
                            wallet = JSON.parse(walletString);
                        }
                        if (!chainStorage) {
                            _ctx.next = 37;
                            break;
                        }
                        chain = DelegationChain.fromJSON(chainStorage);
                        chain.delegations.forEach(function(signedDelegation) {
                            var targets = signedDelegation.delegation.targets && signedDelegation.delegation.targets.length > 0 ? signedDelegation.delegation.targets : undefined;
                            if (targets) {
                                delegationTargets = _toConsumableArray(new Set(delegationTargets.concat(targets.map(function(e) {
                                    return e.toText();
                                }))));
                            }
                        });
                        if (isDelegationValid(chain)) {
                            _ctx.next = 36;
                            break;
                        }
                        _ctx.next = 33;
                        return _deleteStorage(storage);
                    case 33:
                        key = null;
                        _ctx.next = 37;
                        break;
                    case 36:
                        {
                            identity = DelegationIdentity.fromDelegation(key, chain);
                        }
                    case 37:
                        _ctx.next = 45;
                        break;
                    case 39:
                        _ctx.prev = 39;
                        _ctx.t0 = _ctx["catch"](19);
                        console.error(_ctx.t0);
                        _ctx.next = 44;
                        return _deleteStorage(storage);
                    case 44:
                        key = null;
                    case 45:
                        ;
                        _ctx.next = 48;
                        return storage.get(KEY_DELEGATION_PARAMS);
                    case 48:
                        delegationParamsString = _ctx.sent;
                        if (delegationParamsString) {
                            delegationParams = JSON.parse(delegationParamsString);
                            lastRequest = _objectSpreadProps(_objectSpread({}, delegationParams.lastRequest), {
                                maxTimeToLive: delegationParams.lastRequest.maxTimeToLive !== undefined ? BigInt(delegationParams.lastRequest.maxTimeToLive) : undefined
                            });
                            confirm = delegationParams.confirm;
                            delegationIdentity = DelegationIdentity.fromDelegation(key, chain);
                        }
                        ret = new _this(identity, key, chain, storage, wallet, options.appId, delegationIdentity, delegationTargets, lastRequest, confirm, options.idpWindowOption);
                        return _ctx.abrupt("return", ret);
                    case 52:
                    case "end":
                        return _ctx.stop();
                }
            }, _callee, null, [
                [
                    19,
                    39
                ]
            ]);
        }))();
    };
    _createClass(AuthClient, [
        {
            key: "wallet",
            get: function get() {
                return this._wallet;
            }
        }
    ]);
    return AuthClient;
} //
();
