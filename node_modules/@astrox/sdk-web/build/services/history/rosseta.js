/* eslint-disable @typescript-eslint/explicit-module-boundary-types */ /* eslint-disable no-useless-catch */ /* eslint-disable @typescript-eslint/ban-types */ function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _asyncToGenerator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
        }
        ownKeys.forEach(function(key) {
            _defineProperty(target, key, source[key]);
        });
    }
    return target;
}
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) {
            symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
        }
        keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpreadProps(target, source) {
    source = source != null ? source : {};
    if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
        ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
import regeneratorRuntime from "regenerator-runtime";
import fetch from "cross-fetch";
// import {
//   GetTransactionsResponse,
//   Send,
//   Timestamp,
// } from 'src/frontend/generated/nns-dapp';
import { NET_ID, ROSETTA_URL } from "../../utils/constants";
import { formatAssetBySymbol, parseBalance, TokenSymbol } from "../../utils/converter";
import { NNSConnection as nns } from "../../connections/nnsConnection";
export var MILI_PER_SECOND = 1000000;
export var RosettaTransactionStatus;
(function(RosettaTransactionStatus) {
    RosettaTransactionStatus["COMPLETED"] = "COMPLETED";
    RosettaTransactionStatus["REVERTED"] = "REVERTED";
    RosettaTransactionStatus["PENDING"] = "PENDING";
})(RosettaTransactionStatus || (RosettaTransactionStatus = {}));
export var RosettaTransactionType;
(function(RosettaTransactionType) {
    RosettaTransactionType["TRANSACTION"] = "TRANSACTION";
    RosettaTransactionType["FEE"] = "FEE";
    RosettaTransactionType["RECEIVE"] = "RECEIVE";
    RosettaTransactionType["SEND"] = "SEND";
})(RosettaTransactionType || (RosettaTransactionType = {}));
var getTransactionInfo = function(accountId, rosettaTransaction) {
    var operations = rosettaTransaction.operations, _metadata = rosettaTransaction.metadata, ts = _metadata.timestamp, bh = _metadata.block_height, mm = _metadata.memo, lt = _metadata.lockTime, hash = rosettaTransaction.transaction_identifier.hash;
    // console.log('------ getting rosetta transaction start  -------');
    // console.log({ rosettaTransaction });
    // console.log('------ getting rosetta transaction end  -------');
    var transaction = {
        type: RosettaTransactionType.SEND,
        details: {
            status: RosettaTransactionStatus.COMPLETED,
            fee: {},
            from: accountId
        }
    };
    operations.forEach(function(operation) {
        var value = BigInt(operation.amount.value);
        var decimals = operation.amount.currency.decimals;
        var amount = parseBalance({
            value: value.toString(),
            decimals: decimals
        });
        if (operation.type === RosettaTransactionType.FEE) {
            transaction.details.fee.amount = amount;
            transaction.details.fee.currency = operation.amount.currency;
            return;
        }
        if (value >= 0) transaction.details.to = operation.account.address;
        if (value <= 0) transaction.details.from = operation.account.address;
        if (transaction.details.status === RosettaTransactionStatus.COMPLETED && operation.status !== RosettaTransactionStatus.COMPLETED) transaction.details.status = operation.status;
        transaction.type = transaction.details.to === accountId ? RosettaTransactionType.RECEIVE : RosettaTransactionType.SEND;
        transaction.details.amount = amount;
        transaction.details.currency = operation.amount.currency;
    });
    return _objectSpreadProps(_objectSpread({}, transaction), {
        caller: transaction.details.from,
        hash: hash,
        timestamp: ts !== undefined ? (BigInt(ts) / BigInt(MILI_PER_SECOND)).toString() : "",
        block_height: bh !== undefined ? BigInt(bh).toString() : "",
        memo: mm !== undefined ? BigInt(mm).toString() : "",
        lockTime: lt !== undefined ? BigInt(lt).toString() : ""
    });
};
export var getICPTransactions = function() {
    var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(accountId) {
        var response, ref, transactions, total_count, transactionsInfo;
        return regeneratorRuntime.wrap(function _callee$(_ctx) {
            while(1)switch(_ctx.prev = _ctx.next){
                case 0:
                    _ctx.next = 2;
                    return fetch("".concat(ROSETTA_URL, "/search/transactions"), {
                        method: "POST",
                        body: JSON.stringify({
                            network_identifier: NET_ID,
                            account_identifier: {
                                address: accountId
                            }
                        }),
                        headers: {
                            "Content-Type": "application/json",
                            Accept: "*/*"
                        }
                    });
                case 2:
                    response = _ctx.sent;
                    if (response.ok) {
                        _ctx.next = 5;
                        break;
                    }
                    throw Error("GET_TRANSACTIONS_FAILS: ".concat(response.statusText));
                case 5:
                    _ctx.next = 7;
                    return response.json();
                case 7:
                    ref = _ctx.sent;
                    transactions = ref.transactions;
                    total_count = ref.total_count;
                    transactionsInfo = transactions.map(function(param) {
                        var transaction = param.transaction;
                        return getTransactionInfo(accountId, transaction);
                    });
                    return _ctx.abrupt("return", {
                        total: total_count,
                        transactions: transactionsInfo
                    });
                case 12:
                case "end":
                    return _ctx.stop();
            }
        }, _callee);
    }));
    return function getICPTransactions(accountId) {
        return _ref.apply(this, arguments);
    };
}();
export var getTransactions = function() {
    var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(localDelegationIdentity, fromAccount) {
        var result;
        return regeneratorRuntime.wrap(function _callee$(_ctx) {
            while(1)switch(_ctx.prev = _ctx.next){
                case 0:
                    _ctx.next = 2;
                    return nns.getTransactions({
                        delegationIdentity: localDelegationIdentity
                    }, {
                        page_size: 10,
                        offset: 0,
                        account_identifier: fromAccount
                    });
                case 2:
                    result = _ctx.sent;
                    return _ctx.abrupt("return", result);
                case 4:
                case "end":
                    return _ctx.stop();
            }
        }, _callee);
    }));
    return function getTransactions(localDelegationIdentity, fromAccount) {
        return _ref.apply(this, arguments);
    };
}();
export var getICPTransactionsByBlock = function() {
    var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(fromAccount, blockHeight) {
        var response, block, transactions, transactionsInfo;
        return regeneratorRuntime.wrap(function _callee$(_ctx) {
            while(1)switch(_ctx.prev = _ctx.next){
                case 0:
                    _ctx.prev = 0;
                    _ctx.next = 3;
                    return fetch("".concat(ROSETTA_URL, "/block"), {
                        method: "POST",
                        body: JSON.stringify({
                            network_identifier: NET_ID,
                            block_identifier: {
                                index: parseInt(blockHeight.toString())
                            }
                        }),
                        headers: {
                            "Content-Type": "application/json",
                            Accept: "*/*"
                        }
                    });
                case 3:
                    response = _ctx.sent;
                    if (response.ok) {
                        _ctx.next = 6;
                        break;
                    }
                    throw Error("GET_TRANSACTIONS_FAILS: ".concat(response.statusText));
                case 6:
                    _ctx.next = 8;
                    return response.json();
                case 8:
                    block = _ctx.sent.block;
                    transactions = block.transactions;
                    if (!(transactions === undefined || block === undefined)) {
                        _ctx.next = 12;
                        break;
                    }
                    return _ctx.abrupt("return", {
                        total: transactions.length,
                        transactions: []
                    });
                case 12:
                    transactionsInfo = transactions.map(function(transaction) {
                        return getTransactionInfo(fromAccount, transaction);
                    });
                    return _ctx.abrupt("return", {
                        total: transactions.length,
                        transactions: transactionsInfo
                    });
                case 16:
                    _ctx.prev = 16;
                    _ctx.t0 = _ctx["catch"](0);
                    throw _ctx.t0;
                case 19:
                case "end":
                    return _ctx.stop();
            }
        }, _callee, null, [
            [
                0,
                16
            ]
        ]);
    }));
    return function getICPTransactionsByBlock(fromAccount, blockHeight) {
        return _ref.apply(this, arguments);
    };
}();
export var getExactTransaction = function(fromAccount, singleResponse, txns) {
    var sendArgs = singleResponse.sendArgs;
    var amount = sendArgs.amount, created_at_time = sendArgs.created_at_time, memo = sendArgs.memo, to = sendArgs.to;
    var blockHeight = singleResponse.blockHeight;
    var transactions = txns.transactions;
    console.log({
        singleResponse: singleResponse,
        txns: txns
    });
    var found = transactions.find(function(val) {
        return created_at_time[0] !== undefined ? val.timestamp.timestamp_nanos > created_at_time[0].timestamp_nanos : true && val.block_height === blockHeight && val.memo === memo && JSON.stringify(val.transaction_type[0]) === JSON.stringify({
            Send: null
        }) && val.transfer.Send.amount.e8s === amount.e8s && val.transfer.Send.to === to;
    });
    if (found) {
        var res = {
            hash: "",
            timestamp: (BigInt(found.timestamp.timestamp_nanos) / BigInt(1000000)).toString(),
            type: RosettaTransactionType.SEND,
            details: {
                to: to,
                from: fromAccount,
                status: RosettaTransactionStatus.COMPLETED,
                amount: amount.e8s.toString(),
                currency: {
                    symbol: TokenSymbol.ICP,
                    decimals: 10
                },
                fee: {
                    amount: found.transfer.Send.fee.e8s.toString(),
                    currency: {
                        symbol: TokenSymbol.ICP,
                        decimals: 10
                    }
                }
            },
            caller: fromAccount,
            block_height: blockHeight.toString(),
            memo: memo.toString(),
            lockTime: ""
        };
        return res;
    }
    return undefined;
};
// use Rosseta API to fetch transaction list, and return
// This API works on mainnet, however not in local testnet
export var getTransactionFromRosseta = function(fromAccount, singleResponse, txns) {
    var sendArgs = singleResponse.sendArgs;
    var amount = sendArgs.amount, created_at_time = sendArgs.created_at_time, memo = sendArgs.memo, to = sendArgs.to;
    var blockHeight = singleResponse.blockHeight;
    var transactions = txns.transactions;
    var found = transactions.find(function(val) {
        var ref;
        return created_at_time[0] !== undefined ? val.timestamp.length < created_at_time[0].timestamp_nanos.toString().length ? BigInt(val.timestamp) * BigInt(1000000) > created_at_time[0].timestamp_nanos : BigInt(val.timestamp) > created_at_time[0].timestamp_nanos : true && BigInt(val.block_height) === blockHeight && BigInt(val.memo) === memo && val.details.to === to && val.details.amount === ((ref = formatAssetBySymbol(amount.e8s, val.details.currency.symbol)) === null || ref === void 0 ? void 0 : ref.amount.toString()) && val.caller === fromAccount;
    });
    return found;
};
