function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _asyncToGenerator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
import regeneratorRuntime from "regenerator-runtime";
import { Actor, HttpAgent } from "@dfinity/agent";
import { Delegation, DelegationChain, DelegationIdentity, Ed25519KeyIdentity } from "@dfinity/identity";
import { Principal } from "@dfinity/principal";
export function createConnection(identity, delegationIdentity, canisterId, interfaceFactory, actor, agent) {
    return new BaseConnection(identity, delegationIdentity, canisterId, interfaceFactory, actor, agent);
}
export var requestDelegation = function() {
    var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(identity, param) {
        var canisterId, date, sessionKey, chain;
        return regeneratorRuntime.wrap(function _callee$(_ctx) {
            while(1)switch(_ctx.prev = _ctx.next){
                case 0:
                    canisterId = param.canisterId, date = param.date;
                    sessionKey = Ed25519KeyIdentity.generate();
                    _ctx.next = 4;
                    return DelegationChain.create(identity, sessionKey.getPublicKey(), date || new Date(Date.parse("2100-01-01")), {
                        targets: canisterId != undefined ? [
                            Principal.fromText(canisterId)
                        ] : undefined
                    });
                case 4:
                    chain = _ctx.sent;
                    return _ctx.abrupt("return", DelegationIdentity.fromDelegation(sessionKey, chain));
                case 6:
                case "end":
                    return _ctx.stop();
            }
        }, _callee);
    }));
    return function requestDelegation(identity, _) {
        return _ref.apply(this, arguments);
    };
}();
export function _createActor(interfaceFactory, canisterId, identity, host) {
    return __createActor.apply(this, arguments);
}
function __createActor() {
    __createActor = _asyncToGenerator(regeneratorRuntime.mark(function _callee(interfaceFactory, canisterId, identity, host) {
        var ref, ref1, agent, actor;
        return regeneratorRuntime.wrap(function _callee$(_ctx) {
            while(1)switch(_ctx.prev = _ctx.next){
                case 0:
                    ;
                    agent = new HttpAgent({
                        identity: identity,
                        host: host
                    });
                    if (!(process && (((ref = process.env) === null || ref === void 0 ? void 0 : ref.NODE_ENV) === "development" || ((ref1 = process.env) === null || ref1 === void 0 ? void 0 : ref1.II_ENV) === "development"))) {
                        _ctx.next = 5;
                        break;
                    }
                    _ctx.next = 5;
                    return agent.fetchRootKey();
                case 5:
                    actor = Actor.createActor(interfaceFactory, {
                        agent: agent,
                        canisterId: canisterId
                    });
                    return _ctx.abrupt("return", {
                        actor: actor,
                        agent: agent
                    });
                case 7:
                case "end":
                    return _ctx.stop();
            }
        }, _callee);
    }));
    return __createActor.apply(this, arguments);
}
export var BaseConnection = /*#__PURE__*/ function() {
    "use strict";
    function BaseConnection(identity, delegationIdentity, canisterId, interfaceFactory, actor, agent) {
        _classCallCheck(this, BaseConnection);
        this.identity = identity;
        this.delegationIdentity = delegationIdentity;
        this.canisterId = canisterId;
        this.interfaceFactory = interfaceFactory;
        this.actor = actor;
        this.agent = agent;
    }
    var _proto = BaseConnection.prototype;
    _proto.getActor = function getActor() {
        return _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
            return regeneratorRuntime.wrap(function _callee$(_ctx) {
                while(1)switch(_ctx.prev = _ctx.next){
                    case 0:
                        throw new Error("Method not implemented.");
                    case 1:
                    case "end":
                        return _ctx.stop();
                }
            }, _callee);
        }))();
    };
    _proto._getActor = function _getActor(canisterId, interfaceFactory, date) {
        var _this = this;
        return _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
            var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, delegation, _canisterId, _canisterId1;
            return regeneratorRuntime.wrap(function _callee$(_ctx) {
                while(1)switch(_ctx.prev = _ctx.next){
                    case 0:
                        if (!_this.delegationIdentity) {
                            _ctx.next = 26;
                            break;
                        }
                        _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                        _ctx.prev = 2;
                        _iterator = _this.delegationIdentity.getDelegation().delegations[Symbol.iterator]();
                    case 4:
                        if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                            _ctx.next = 12;
                            break;
                        }
                        delegation = _step.value.delegation;
                        if (!(+new Date(Number(delegation.expiration / BigInt(1000000))) <= +Date.now())) {
                            _ctx.next = 9;
                            break;
                        }
                        _this.actor = undefined;
                        return _ctx.abrupt("break", 12);
                    case 9:
                        _iteratorNormalCompletion = true;
                        _ctx.next = 4;
                        break;
                    case 12:
                        _ctx.next = 18;
                        break;
                    case 14:
                        _ctx.prev = 14;
                        _ctx.t0 = _ctx["catch"](2);
                        _didIteratorError = true;
                        _iteratorError = _ctx.t0;
                    case 18:
                        _ctx.prev = 18;
                        _ctx.prev = 19;
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    case 21:
                        _ctx.prev = 21;
                        if (!_didIteratorError) {
                            _ctx.next = 24;
                            break;
                        }
                        throw _iteratorError;
                    case 24:
                        return _ctx.finish(21);
                    case 25:
                        return _ctx.finish(18);
                    case 26:
                        if (!(_this.actor === undefined)) {
                            _ctx.next = 35;
                            break;
                        }
                        ;
                        _ctx.next = 30;
                        return requestDelegation(_this.identity, {
                            canisterId: (_canisterId = _this.canisterId) !== null && _canisterId !== void 0 ? _canisterId : canisterId,
                            date: date !== null && date !== void 0 ? date : undefined
                        });
                    case 30:
                        // Create our actor with a DelegationIdentity to avoid re-prompting auth
                        _this.delegationIdentity = _ctx.sent;
                        ;
                        _ctx.next = 34;
                        return _createActor(interfaceFactory, (_canisterId1 = _this.canisterId) !== null && _canisterId1 !== void 0 ? _canisterId1 : canisterId, _this.delegationIdentity);
                    case 34:
                        _this.actor = _ctx.sent.actor;
                    case 35:
                        return _ctx.abrupt("return", _this.actor);
                    case 36:
                    case "end":
                        return _ctx.stop();
                }
            }, _callee, null, [
                [
                    2,
                    14,
                    18,
                    26
                ],
                [
                    19,
                    ,
                    21,
                    25
                ]
            ]);
        }))();
    };
    return BaseConnection;
}();
export function handleDelegation(message, key) {
    return _handleDelegation.apply(this, arguments);
}
function _handleDelegation() {
    _handleDelegation = _asyncToGenerator(regeneratorRuntime.mark(function _callee(message, key) {
        var delegations, delegationChain;
        return regeneratorRuntime.wrap(function _callee$(_ctx) {
            while(1)switch(_ctx.prev = _ctx.next){
                case 0:
                    delegations = message.delegations.map(function(signedDelegation) {
                        return {
                            delegation: new Delegation(signedDelegation.delegation.pubkey, signedDelegation.delegation.expiration, signedDelegation.delegation.targets),
                            signature: signedDelegation.signature.buffer
                        };
                    });
                    delegationChain = DelegationChain.fromDelegations(delegations, message.userPublicKey.buffer);
                    return _ctx.abrupt("return", {
                        delegationChain: delegationChain,
                        delegationIdentity: DelegationIdentity.fromDelegation(key, delegationChain)
                    });
                case 3:
                case "end":
                    return _ctx.stop();
            }
        }, _callee);
    }));
    return _handleDelegation.apply(this, arguments);
}
export var executeWithLogging = function() {
    var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(func) {
        return regeneratorRuntime.wrap(function _callee$(_ctx) {
            while(1)switch(_ctx.prev = _ctx.next){
                case 0:
                    _ctx.prev = 0;
                    _ctx.next = 3;
                    return func();
                case 3:
                    return _ctx.abrupt("return", _ctx.sent);
                case 6:
                    _ctx.prev = 6;
                    _ctx.t0 = _ctx["catch"](0);
                    console.log(_ctx.t0);
                    throw _ctx.t0;
                case 10:
                case "end":
                    return _ctx.stop();
            }
        }, _callee, null, [
            [
                0,
                6
            ]
        ]);
    }));
    return function executeWithLogging(func) {
        return _ref.apply(this, arguments);
    };
}();
