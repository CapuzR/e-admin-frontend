{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["import { PublicKey } from '@dfinity/agent';\nimport { DelegationChain } from '@dfinity/identity';\nimport { Principal } from '@dfinity/principal';\n\nconst DEFAULT_IDENTITY_PROVIDER_URL = 'https://auth.ic0.app/authorize';\n\nfunction toHexString(bytes: ArrayBuffer): string {\n  return new Uint8Array(bytes).reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n}\n\nfunction _getDefaultLocation() {\n  if (typeof window === 'undefined') {\n    throw new Error('Could not find default location.');\n  }\n\n  return window.location.origin;\n}\n\n/**\n * Options for {@link createAuthenticationRequestUrl}. All these options may be limited\n * further by the identity provider, or an error can happen.\n */\nexport interface CreateUrlOptions {\n  /**\n   * The public key to delegate to. This should be the public key of the session key.\n   */\n  publicKey: PublicKey;\n\n  /**\n   * The scope of the delegation. This must contain at least one key and a maximum\n   * of four. This is validated in {@link createAuthenticationRequestUrl} but also\n   * will be validated as part of the identity provider.\n   */\n  scope: Array<string | Principal>;\n\n  /**\n   * The URI to redirect to, after authentication. By default, `window.location.origin`.\n   */\n  redirectUri?: string;\n\n  /**\n   * The URL base to use for the identity provider.\n   * By default, this is \"https://auth.ic0.app/authorize\".\n   */\n  identityProvider?: URL | string;\n}\n\n/**\n * List of things to check for a delegation chain validity.\n */\nexport interface DelegationValidChecks {\n  /**\n   * Check that the scope is amongst the scopes that this delegation has access to.\n   */\n  scope?: Principal | string | Array<Principal | string>;\n}\n\n/**\n * A parsed access token.\n */\nexport type AccessToken = string & { _BRAND: 'access_token' };\n\n/**\n * Create a URL that can be used to redirect the browser to request authentication (e.g. using\n * the authentication provider). Will throw if some options are invalid.\n * @param options An option with all options for the authentication request.\n */\nexport function createAuthenticationRequestUrl(options: CreateUrlOptions): URL {\n  const url = new URL(options.identityProvider?.toString() ?? DEFAULT_IDENTITY_PROVIDER_URL);\n  url.searchParams.set('response_type', 'token');\n  url.searchParams.set('login_hint', toHexString(options.publicKey.toDer()));\n  url.searchParams.set('redirect_uri', options.redirectUri ?? _getDefaultLocation());\n  url.searchParams.set(\n    'scope',\n    options.scope\n      .map(p => {\n        if (typeof p === 'string') {\n          return Principal.fromText(p);\n        } else {\n          return p;\n        }\n      })\n      .map(p => p.toString())\n      .join(' '),\n  );\n  url.searchParams.set('state', '');\n\n  return url;\n}\n\n/**\n * Returns an AccessToken from the Window object. This cannot be used in Node, instead use\n * the {@link getAccessTokenFromURL} function.\n *\n * An access token is needed to create a DelegationChain object.\n */\nexport function getAccessTokenFromWindow(): AccessToken | null {\n  if (typeof window === 'undefined') {\n    return null;\n  }\n  return getAccessTokenFromURL(new URL(window.location.href));\n}\n\n/**\n * Analyze a URL and try to extract an AccessToken from it.\n * @param url The URL to look into.\n */\nexport function getAccessTokenFromURL(url: URL | string): AccessToken | null {\n  // Remove the `#` at the start.\n  const hashParams = new URLSearchParams(new URL(url.toString()).hash.substr(1));\n  return hashParams.get('access_token') as AccessToken | null;\n}\n\n/**\n * Create a DelegationChain from an AccessToken extracted from a redirect URL.\n * @param accessToken The access token extracted from a redirect URL.\n */\nexport function createDelegationChainFromAccessToken(accessToken: AccessToken): DelegationChain {\n  // Transform the HEXADECIMAL string into the JSON it represents.\n  if (/[^0-9a-fA-F]/.test(accessToken) || accessToken.length % 2) {\n    throw new Error('Invalid hexadecimal string for accessToken.');\n  }\n  const chainJson = [...accessToken]\n    .reduce((acc, curr, i) => {\n      // tslint:disable-next-line:no-bitwise\n      acc[(i / 2) | 0] = (acc[(i / 2) | 0] || '') + curr;\n      return acc;\n    }, [] as string[])\n    .map(x => Number.parseInt(x, 16))\n    .map(x => String.fromCharCode(x))\n    .join('');\n\n  return DelegationChain.fromJSON(chainJson);\n}\n\n/**\n * Analyze a DelegationChain and validate that it's valid, ie. not expired and apply to the\n * scope.\n * @param chain The chain to validate.\n * @param checks Various checks to validate on the chain.\n */\nexport function isDelegationValid(chain: DelegationChain, checks?: DelegationValidChecks): boolean {\n  // Verify that the no delegation is expired. If any are in the chain, returns false.\n  for (const { delegation } of chain.delegations) {\n    // prettier-ignore\n    if (+new Date(Number(delegation.expiration / BigInt(1000000))) <= +Date.now()) {\n      return false;\n    }\n  }\n\n  // Check the scopes.\n  const scopes: Principal[] = [];\n  const maybeScope = checks?.scope;\n  if (maybeScope) {\n    if (Array.isArray(maybeScope)) {\n      scopes.push(...maybeScope.map(s => (typeof s === 'string' ? Principal.fromText(s) : s)));\n    } else {\n      scopes.push(typeof maybeScope === 'string' ? Principal.fromText(maybeScope) : maybeScope);\n    }\n  }\n\n  for (const s of scopes) {\n    const scope = s.toText();\n    for (const { delegation } of chain.delegations) {\n      if (delegation.targets === undefined) {\n        continue;\n      }\n\n      let none = true;\n      for (const target of delegation.targets) {\n        if (target.toText() === scope) {\n          none = false;\n          break;\n        }\n      }\n      if (none) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n"]}