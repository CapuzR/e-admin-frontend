"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const client_1 = __importDefault(require("@walletconnect/client"));
const browser_utils_1 = require("@walletconnect/browser-utils");
const jsonrpc_utils_1 = require("@walletconnect/jsonrpc-utils");
const buffer_1 = require("buffer/");
const wallet_connect_1 = require("../constants/wallet-connect");
const signer_server_1 = __importDefault(require("./signer-server"));
if (typeof global.Buffer === "undefined") {
    global.Buffer = buffer_1.Buffer;
}
class WalletConnectRPC {
    constructor(walletConnectOptions) {
        this.wcBridgeURL = "https://bridge.walletconnect.org";
        this.agent = null;
        this.isAndroid = false;
        this.isApple = false;
        this.whitelist = [];
        this.publicKey = null;
        const { window, debug = true } = walletConnectOptions;
        this.isAndroid = (0, browser_utils_1.isAndroid)();
        this.isApple = (0, browser_utils_1.isIOS)();
        this.window = window;
        this.debug = debug;
        this.debug && console.log("isAndroid", this.isAndroid);
        this.debug && console.log("isApple", this.isApple);
        this.wcClient = new client_1.default({
            bridge: this.wcBridgeURL,
            signingMethods: wallet_connect_1.SIGN_METHODS,
        });
    }
    start() { }
    call(handler, args, options = { timeout: wallet_connect_1.DEFAULT_TIMEOUT }) {
        const timeout = typeof options.timeout === "number" ? options.timeout : wallet_connect_1.DEFAULT_TIMEOUT;
        return new Promise((resolve, reject) => {
            const timeoutFun = timeout > 0
                ? setTimeout(() => {
                    reject(new Error("Timeout"));
                }, timeout)
                : null;
            const resolveAndClear = (response) => {
                if (timeoutFun)
                    clearTimeout(timeoutFun);
                resolve(response);
            };
            const rejectAndClear = (error) => {
                if (timeoutFun)
                    clearTimeout(timeoutFun);
                reject(error);
            };
            switch (handler) {
                case "requestConnect":
                    return this.requestConnect(args, resolveAndClear, rejectAndClear);
                case "handleError":
                    throw new Error(args[1]);
                case "requestCall":
                    return this.requestCall(args, resolveAndClear, rejectAndClear);
                case "requestQuery":
                    return this.requestQuery(args, resolveAndClear, rejectAndClear);
                case "requestReadState":
                    return this.requestReadState(args, resolveAndClear, rejectAndClear);
                case "verifyWhitelist":
                    return this.verifyWhitelist(args, resolveAndClear, rejectAndClear);
                case "disconnect":
                    return this.disconnect(args, resolveAndClear, rejectAndClear);
                case "batchTransactions":
                    return this.batchTransactions(args, resolveAndClear, rejectAndClear);
                default:
                    return this._call(handler, args, resolveAndClear, rejectAndClear);
            }
        });
    }
    resetSession() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.clearClient();
            yield this.wcClient.createSession();
        });
    }
    _call(handler, args, resolve, reject) {
        const requestId = (0, jsonrpc_utils_1.payloadId)();
        if (wallet_connect_1.SIGN_METHODS.includes(handler)) {
            this.window.location.href = `${this.focusUri}?requestId=${requestId}`;
        }
        this.debug && console.log("going to _calling", handler);
        this.wcClient
            .sendCustomRequest({
            id: requestId,
            method: handler,
            params: args,
        })
            .then((response) => {
            this.debug && console.log("_called", handler, response);
            resolve(response);
        })
            .catch((error) => {
            this.debug && console.log("_called error", handler, error);
            reject(error);
        });
    }
    requestConnect(args, resolve, reject) {
        return __awaiter(this, void 0, void 0, function* () {
            const href = !this.isAndroid
                ? (0, browser_utils_1.formatIOSMobile)(this.wcClient.uri, wallet_connect_1.WC_MOBILE_REGISTRY_ENTRY)
                : this.wcClient.uri;
            this.focusUri = href.split("?")[0];
            const requestId = (0, jsonrpc_utils_1.payloadId)();
            this.window.location.href = `${href}&requestId=${requestId}`;
            this.wcClient.on("disconnect", (_error, payload) => __awaiter(this, void 0, void 0, function* () {
                this.debug && console.log("on disconnect", payload);
                yield this.resetSession();
                const [error] = payload.params;
                reject(error);
            }));
            this.wcClient.on("connect", (error, payload) => {
                this.debug && console.log("on connect", payload);
                if (error) {
                    reject(error);
                }
                this.wcClient
                    .sendCustomRequest({
                    id: requestId,
                    method: "requestConnect",
                    params: args,
                })
                    .then((response) => {
                    this.wcClient.off("disconnect");
                    const { publicKey, whitelist } = response;
                    this.addToWhiteList(whitelist);
                    this.publicKey = publicKey;
                    resolve(publicKey);
                })
                    .catch((error) => __awaiter(this, void 0, void 0, function* () {
                    yield this.resetSession();
                    reject(error);
                }));
            });
        });
    }
    requestCall(args, resolve, reject) {
        return __awaiter(this, void 0, void 0, function* () {
            const [_metadata, _args, batchTxId] = args;
            const requestId = (0, jsonrpc_utils_1.payloadId)();
            if (!batchTxId) {
                this.window.location.href = `${this.focusUri}?requestId=${requestId}`;
            }
            if (this.isApple && batchTxId) {
                this.debug && console.log("isApple requestCall by SignerServer");
                return signer_server_1.default.requestCall(args, resolve, reject);
            }
            this.debug && console.log("requestingCall");
            this.wcClient
                .sendCustomRequest({
                id: requestId,
                method: "requestCall",
                params: args,
            })
                .then((response) => {
                this.debug && console.log("requestedCall", response);
                resolve(response);
            })
                .catch((error) => {
                this.debug && console.log("requestedCall", error);
                reject(error);
            });
        });
    }
    requestQuery(args, resolve, reject) {
        return __awaiter(this, void 0, void 0, function* () {
            const [_metadata, _args, batchTxId] = args;
            if (this.isApple && batchTxId) {
                this.debug && console.log("isApple requestQuery by SignerServer");
                return signer_server_1.default.requestQuery(args, resolve, reject);
            }
            this._call("requestQuery", args, resolve, reject);
        });
    }
    requestReadState(args, resolve, reject) {
        return __awaiter(this, void 0, void 0, function* () {
            const [_metadata, _args, batchTxId] = args;
            if (this.isApple && batchTxId) {
                this.debug && console.log("isApple requestReadState by SignerServer");
                return signer_server_1.default.requestReadState(args, resolve, reject);
            }
            this._call("requestReadState", args, resolve, reject);
        });
    }
    verifyWhitelist(args, resolve, reject) {
        return __awaiter(this, void 0, void 0, function* () {
            this.debug && console.log("going to verifyingWhitelist allWhitelisted");
            const allWhiteListed = this.isAllWhiteListed(args[1]);
            if (allWhiteListed) {
                resolve(this.publicKey);
                return;
            }
            const verifyRequestId = (0, jsonrpc_utils_1.payloadId)();
            this.window.location.href = `${this.focusUri}?requestId=${verifyRequestId}`;
            this.debug &&
                console.log("verifyingWhitelist allWhitelisted", allWhiteListed);
            this.debug && console.log("going to verifyingWhitelist");
            this.wcClient
                .sendCustomRequest({
                id: verifyRequestId,
                method: "verifyWhitelist",
                params: args,
            })
                .then((response) => {
                this.debug && console.log("verifyedWhitelist", response);
                const { publicKey, whitelist } = response;
                this.addToWhiteList(whitelist);
                this.publicKey = publicKey;
                resolve(publicKey);
            })
                .catch((error) => {
                this.debug && console.log("verifyedWhitelist error", error);
                reject(error);
            });
        });
    }
    disconnect(args, resolve, reject) {
        return __awaiter(this, void 0, void 0, function* () {
            this.wcClient
                .sendCustomRequest({
                method: "disconnect",
                params: args,
            })
                .then((res) => {
                resolve();
            })
                .catch((err) => {
                reject(err);
            });
            yield this.resetSession();
        });
    }
    clearClient() {
        return __awaiter(this, void 0, void 0, function* () {
            this.wcClient.off("disconnect");
            this.wcClient.off("connect");
            if (this.wcClient.connected) {
                yield this.wcClient.killSession();
            }
            this.wcClient = new client_1.default({
                bridge: this.wcBridgeURL,
                signingMethods: wallet_connect_1.SIGN_METHODS,
            });
        });
    }
    isAllWhiteListed(newWhiteList) {
        return newWhiteList.every((element) => this.whitelist.includes(element));
    }
    addToWhiteList(newWhiteList) {
        newWhiteList.forEach((element) => {
            if (!this.whitelist.includes(element)) {
                this.whitelist.push(element);
            }
        });
    }
    batchTransactions(args, resolve, reject) {
        return __awaiter(this, void 0, void 0, function* () {
            const requestId = (0, jsonrpc_utils_1.payloadId)();
            this.window.location.href = `${this.focusUri}?requestId=${requestId}`;
            this.wcClient.sendCustomRequest({
                id: requestId,
                method: "batchTransactions",
                params: args,
            }).then((response) => {
                this.debug && console.log("batchTransactions", response);
                const { whitelist } = response, result = __rest(response, ["whitelist"]);
                this.addToWhiteList(whitelist);
                resolve(result);
            })
                .catch((error) => {
                this.debug && console.log("batchTransactions error", error);
                reject(error);
            });
        });
    }
}
exports.default = WalletConnectRPC;
