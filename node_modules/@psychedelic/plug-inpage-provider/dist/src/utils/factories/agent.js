"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.readStateMethodFactory = exports.queryMethodFactory = exports.callMethodFactory = void 0;
const candid_1 = require("@dfinity/candid");
const buffer_1 = require("buffer/");
const bigint_1 = require("../bigint");
const communication_1 = require("../communication");
const domain_metadata_1 = __importDefault(require("../domain-metadata"));
const callMethodFactory = (clientRPC, batchTxId = "", idl) => (canisterId, options, identity) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    const metadata = (0, domain_metadata_1.default)();
    let decodedArgs = null;
    if (idl) {
        decodedArgs = (0, bigint_1.recursiveParseBigint)(candid_1.IDL.decode(idl[options.methodName], options.arg));
    }
    const arg = (0, communication_1.bufferToBase64)(buffer_1.Buffer.from((0, candid_1.blobToUint8Array)(options.arg).buffer));
    const result = yield clientRPC.call({
        handler: "requestCall",
        args: [
            metadata,
            {
                canisterId: canisterId.toString(),
                methodName: options.methodName,
                arg,
                effectiveCanisterId: (_a = options.effectiveCanisterId) === null || _a === void 0 ? void 0 : _a.toString(),
            },
            batchTxId,
            decodedArgs,
        ],
    });
    if (result.error)
        throw result.error.message;
    return Object.assign(Object.assign({}, result), { requestId: (0, candid_1.blobFromUint8Array)(new Uint8Array((0, communication_1.base64ToBuffer)(result.requestId))) });
});
exports.callMethodFactory = callMethodFactory;
const queryMethodFactory = (clientRPC, batchTxId = "") => (canisterId, fields, identity) => __awaiter(void 0, void 0, void 0, function* () {
    const metadata = (0, domain_metadata_1.default)();
    const result = yield clientRPC.call({
        handler: "requestQuery",
        args: [
            metadata,
            {
                canisterId: canisterId.toString(),
                methodName: fields.methodName,
                arg: (0, communication_1.bufferToBase64)(buffer_1.Buffer.from((0, candid_1.blobToUint8Array)(fields.arg).buffer)),
                url: (0, domain_metadata_1.default)().url,
            },
            batchTxId,
        ],
    });
    if (result.error)
        throw result.error.message;
    return result.status === "replied"
        ? Object.assign(Object.assign({}, result), { reply: {
                arg: (0, candid_1.blobFromUint8Array)(new Uint8Array((0, communication_1.base64ToBuffer)(result.reply.arg))),
            } }) : Object.assign({}, result);
});
exports.queryMethodFactory = queryMethodFactory;
const readStateMethodFactory = (clientRPC, batchTxId = "") => (canisterId, fields, identity) => __awaiter(void 0, void 0, void 0, function* () {
    const paths = fields.paths[0].map((path) => (0, communication_1.bufferToBase64)(buffer_1.Buffer.from((0, candid_1.blobToUint8Array)(path).buffer)));
    try {
        const metadata = (0, domain_metadata_1.default)();
        const result = yield clientRPC.call({
            handler: "requestReadState",
            args: [
                metadata,
                {
                    canisterId: canisterId.toString(),
                    paths,
                    url: (0, domain_metadata_1.default)().url,
                },
                batchTxId,
            ],
        });
        if (result.error)
            throw result.error.message;
        return {
            certificate: (0, candid_1.blobFromUint8Array)(new Uint8Array((0, communication_1.base64ToBuffer)(result.certificate))),
        };
    }
    catch (e) {
        throw e;
    }
});
exports.readStateMethodFactory = readStateMethodFactory;
