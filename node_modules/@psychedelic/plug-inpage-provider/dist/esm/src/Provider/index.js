var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
import { Actor } from "@dfinity/agent";
import { Principal } from "@dfinity/principal";
import { Buffer } from "buffer/";
import getDomainMetadata from "../utils/domain-metadata";
import { managementCanisterIdlFactory, managementCanisterPrincipal, transformOverrideHandler, } from "../utils/ic-management-api";
import { versions } from "../constants";
import { getArgTypes, getSignInfoFromTransaction, } from "../utils/sign";
import { createActor, createAgent } from "../utils/agent";
import { recursiveParseBigint } from "../utils/bigint";
import RPCManager from "../modules/RPCManager";
import SessionManager from "../modules/SessionManager";
import { validateCanisterId } from "../utils/account";
import { bufferToBase64 } from "../utils/communication";
import WalletConnectRPC from "../utils/wallet-connect-rpc";
export default class Provider {
    constructor(clientRPC) {
        this.idls = {};
        this.hookToWindowEvents = () => {
            window.addEventListener("updateConnection", () => __awaiter(this, void 0, void 0, function* () {
                const connectionData = yield this.sessionManager.updateConnection();
                const { sessionData } = connectionData || {};
                if (sessionData) {
                    this.agent = sessionData === null || sessionData === void 0 ? void 0 : sessionData.agent;
                    this.principalId = sessionData === null || sessionData === void 0 ? void 0 : sessionData.principalId;
                    this.accountId = sessionData === null || sessionData === void 0 ? void 0 : sessionData.accountId;
                }
            }), false);
        };
        this.clientRPC = new RPCManager({ instance: clientRPC });
        this.sessionManager = new SessionManager({ rpc: this.clientRPC });
        this.versions = versions;
    }
    static createWithWalletConnect(walletConnectOptions) {
        const walletConnectRPC = new WalletConnectRPC(walletConnectOptions);
        walletConnectRPC.resetSession();
        return new Provider(walletConnectRPC);
    }
    static exposeProviderWithWalletConnect(walletConnectOptions) {
        const provider = this.createWithWalletConnect(walletConnectOptions);
        const ic = window.ic || {};
        window.ic = Object.assign(Object.assign({}, ic), { plug: provider });
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            const connectionData = yield this.sessionManager.init();
            const { sessionData } = connectionData || {};
            if (sessionData) {
                this.agent = sessionData === null || sessionData === void 0 ? void 0 : sessionData.agent;
                this.principalId = sessionData === null || sessionData === void 0 ? void 0 : sessionData.principalId;
                this.accountId = sessionData === null || sessionData === void 0 ? void 0 : sessionData.accountId;
            }
            this.hookToWindowEvents();
        });
    }
    createActor({ canisterId, interfaceFactory, }) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (!canisterId || !validateCanisterId(canisterId))
                throw Error("a canisterId valid is a required argument");
            if (!interfaceFactory)
                throw Error("interfaceFactory is a required argument");
            const metadata = getDomainMetadata();
            this.idls[canisterId] = getArgTypes(interfaceFactory);
            const connectionData = yield this.sessionManager.getConnectionData();
            const agent = yield createAgent(this.clientRPC, metadata, { whitelist: [canisterId], host: (_a = connectionData === null || connectionData === void 0 ? void 0 : connectionData.connection) === null || _a === void 0 ? void 0 : _a.host }, getArgTypes(interfaceFactory));
            return createActor(agent, canisterId, interfaceFactory);
        });
    }
    getPrincipal({ asString } = { asString: false }) {
        return __awaiter(this, void 0, void 0, function* () {
            const metadata = getDomainMetadata();
            const principal = this.principalId;
            if (principal) {
                return asString ? principal.toString() : Principal.from(principal);
            }
            else {
                const response = yield this.clientRPC.call({
                    handler: "getPrincipal",
                    args: [metadata.url],
                });
                if (response && asString) {
                    return response.toString();
                }
                return Principal.from(response);
            }
        });
    }
    isConnected() {
        return __awaiter(this, void 0, void 0, function* () {
            const connectionData = yield this.sessionManager.getConnectionData();
            const { connection } = connectionData || {};
            return !!connection;
        });
    }
    disconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.sessionManager.disconnect();
        });
    }
    requestConnect(args = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { sessionData, connection } = yield this.sessionManager.requestConnect(args);
            if (sessionData) {
                this.agent = sessionData === null || sessionData === void 0 ? void 0 : sessionData.agent;
                this.principalId = sessionData === null || sessionData === void 0 ? void 0 : sessionData.principalId;
                this.accountId = sessionData === null || sessionData === void 0 ? void 0 : sessionData.accountId;
            }
            return connection === null || connection === void 0 ? void 0 : connection.publicKey;
        });
    }
    createAgent({ whitelist, host, } = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const metadata = getDomainMetadata();
            this.agent = yield createAgent(this.clientRPC, metadata, { whitelist, host }, null);
            return !!this.agent;
        });
    }
    requestBalance(accountId = null) {
        return __awaiter(this, void 0, void 0, function* () {
            const metadata = getDomainMetadata();
            const balances = yield this.clientRPC.call({
                handler: "requestBalance",
                args: [metadata, accountId],
            });
            return balances.map((balance) => {
                const { value } = balance, rest = __rest(balance, ["value"]);
                return rest;
            });
        });
    }
    requestTransfer(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const metadata = getDomainMetadata();
            return yield this.clientRPC.call({
                handler: "requestTransfer",
                args: [metadata, params],
            });
        });
    }
    batchTransactions(transactions) {
        var transactions_1, transactions_1_1;
        var e_1, _a;
        var _b;
        return __awaiter(this, void 0, void 0, function* () {
            const metadata = getDomainMetadata();
            const canisterList = transactions.map((transaction) => transaction.canisterId);
            const connectionData = yield this.sessionManager.getConnectionData();
            const sender = (yield this.getPrincipal({ asString: true }));
            const signInfo = transactions
                .map((trx) => getSignInfoFromTransaction(trx, sender))
                .map((trx) => recursiveParseBigint(Object.assign(Object.assign({}, trx), { arguments: bufferToBase64(Buffer.from(trx.arguments)) })));
            const batchResponse = yield this.clientRPC.call({
                handler: "batchTransactions",
                args: [metadata, signInfo],
            });
            if (!batchResponse.status)
                return false;
            const agent = yield createAgent(this.clientRPC, metadata, {
                whitelist: canisterList,
                host: (_b = connectionData === null || connectionData === void 0 ? void 0 : connectionData.connection) === null || _b === void 0 ? void 0 : _b.host,
            }, null, batchResponse.txId);
            let transactionIndex = 0;
            let prevTransactionsData = [];
            try {
                for (transactions_1 = __asyncValues(transactions); transactions_1_1 = yield transactions_1.next(), !transactions_1_1.done;) {
                    const transaction = transactions_1_1.value;
                    const actor = yield createActor(agent, transaction.canisterId, transaction.idl);
                    const method = actor[transaction.methodName];
                    try {
                        let response;
                        if (typeof transaction.args === "function") {
                            if (prevTransactionsData) {
                                response = yield method(...transaction.args(prevTransactionsData));
                            }
                            if (!prevTransactionsData) {
                                response = yield method(...transaction.args());
                            }
                        }
                        else if (Array.isArray(transaction.args)) {
                            response = yield method(...transaction.args);
                        }
                        else {
                            yield (transaction === null || transaction === void 0 ? void 0 : transaction.onFail("Invalid transaction arguments, must be function or array", prevTransactionsData));
                            break;
                        }
                        if (transaction === null || transaction === void 0 ? void 0 : transaction.onSuccess) {
                            const chainedResponse = yield (transaction === null || transaction === void 0 ? void 0 : transaction.onSuccess(response));
                            if (chainedResponse) {
                                prevTransactionsData = [
                                    ...prevTransactionsData,
                                    { transactionIndex, response: chainedResponse },
                                ];
                            }
                        }
                    }
                    catch (error) {
                        if (transaction === null || transaction === void 0 ? void 0 : transaction.onFail) {
                            yield transaction.onFail(error, prevTransactionsData);
                        }
                        break;
                    }
                    transactionIndex++;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (transactions_1_1 && !transactions_1_1.done && (_a = transactions_1.return)) yield _a.call(transactions_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return true;
        });
    }
    getICNSInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            const metadata = getDomainMetadata();
            return yield this.clientRPC.call({
                handler: "getICNSInfo",
                args: [metadata],
            });
        });
    }
    requestBurnXTC(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const metadata = getDomainMetadata();
            return yield this.clientRPC.call({
                handler: "requestBurnXTC",
                args: [metadata, params],
            });
        });
    }
    getManagementCanister() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.agent) {
                throw Error("Oops! Agent initialization required.");
            }
            return Actor.createActor(managementCanisterIdlFactory, Object.assign({ agent: this.agent, canisterId: managementCanisterPrincipal }, {
                callTransform: transformOverrideHandler,
                queryTransform: transformOverrideHandler,
            }));
        });
    }
    requestImportToken(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const metadata = getDomainMetadata();
            return yield this.clientRPC.call({
                handler: "requestImportToken",
                args: [metadata, params],
            });
        });
    }
}
