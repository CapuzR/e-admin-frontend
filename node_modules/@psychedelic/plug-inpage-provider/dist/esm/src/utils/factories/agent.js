var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { blobFromUint8Array, blobToUint8Array, IDL, } from "@dfinity/candid";
import { Buffer } from "buffer/";
import { recursiveParseBigint } from "../bigint";
import { base64ToBuffer, bufferToBase64 } from "../communication";
import getDomainMetadata from "../domain-metadata";
export const callMethodFactory = (clientRPC, batchTxId = "", idl) => (canisterId, options, identity) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    const metadata = getDomainMetadata();
    let decodedArgs = null;
    if (idl) {
        decodedArgs = recursiveParseBigint(IDL.decode(idl[options.methodName], options.arg));
    }
    const arg = bufferToBase64(Buffer.from(blobToUint8Array(options.arg).buffer));
    const result = yield clientRPC.call({
        handler: "requestCall",
        args: [
            metadata,
            {
                canisterId: canisterId.toString(),
                methodName: options.methodName,
                arg,
                effectiveCanisterId: (_a = options.effectiveCanisterId) === null || _a === void 0 ? void 0 : _a.toString(),
            },
            batchTxId,
            decodedArgs,
        ],
    });
    if (result.error)
        throw result.error.message;
    return Object.assign(Object.assign({}, result), { requestId: blobFromUint8Array(new Uint8Array(base64ToBuffer(result.requestId))) });
});
export const queryMethodFactory = (clientRPC, batchTxId = "") => (canisterId, fields, identity) => __awaiter(void 0, void 0, void 0, function* () {
    const metadata = getDomainMetadata();
    const result = yield clientRPC.call({
        handler: "requestQuery",
        args: [
            metadata,
            {
                canisterId: canisterId.toString(),
                methodName: fields.methodName,
                arg: bufferToBase64(Buffer.from(blobToUint8Array(fields.arg).buffer)),
                url: getDomainMetadata().url,
            },
            batchTxId,
        ],
    });
    if (result.error)
        throw result.error.message;
    return result.status === "replied"
        ? Object.assign(Object.assign({}, result), { reply: {
                arg: blobFromUint8Array(new Uint8Array(base64ToBuffer(result.reply.arg))),
            } }) : Object.assign({}, result);
});
export const readStateMethodFactory = (clientRPC, batchTxId = "") => (canisterId, fields, identity) => __awaiter(void 0, void 0, void 0, function* () {
    const paths = fields.paths[0].map((path) => bufferToBase64(Buffer.from(blobToUint8Array(path).buffer)));
    try {
        const metadata = getDomainMetadata();
        const result = yield clientRPC.call({
            handler: "requestReadState",
            args: [
                metadata,
                {
                    canisterId: canisterId.toString(),
                    paths,
                    url: getDomainMetadata().url,
                },
                batchTxId,
            ],
        });
        if (result.error)
            throw result.error.message;
        return {
            certificate: blobFromUint8Array(new Uint8Array(base64ToBuffer(result.certificate))),
        };
    }
    catch (e) {
        throw e;
    }
});
