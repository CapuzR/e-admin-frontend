import { sha256 as jsSha256 } from "js-sha256";
import borc from "borc";
import { Buffer } from "buffer/";
import { blobFromBuffer, blobFromUint8Array, blobToHex, lebEncode, } from "@dfinity/candid";
import { Principal } from "@dfinity/principal";
import { TextEncoder } from 'text-encoding-shim';
export function toHex(requestId) {
    return blobToHex(requestId);
}
export function hash(data) {
    const hashed = jsSha256.create().update(data).arrayBuffer();
    return blobFromUint8Array(new Uint8Array(hashed));
}
function hashValue(value) {
    if (value instanceof borc.Tagged) {
        return hashValue(value.value);
    }
    else if (typeof value === "string") {
        return hashString(value);
    }
    else if (typeof value === "number") {
        return hash(lebEncode(value));
    }
    else if (Buffer.isBuffer(value)) {
        return hash(blobFromUint8Array(new Uint8Array(value)));
    }
    else if (value instanceof Uint8Array || value instanceof ArrayBuffer) {
        return hash(blobFromUint8Array(new Uint8Array(value)));
    }
    else if (Array.isArray(value)) {
        const vals = value.map(hashValue);
        return hash(Buffer.concat(vals));
    }
    else if (value instanceof Principal) {
        return hash(blobFromUint8Array(value.toUint8Array()));
    }
    else if (value._isPrincipal) {
        return hash(blobFromUint8Array(value._arr));
    }
    else if (typeof value === "object" &&
        value !== null &&
        typeof value.toHash === "function") {
        return hashValue(value.toHash());
    }
    else if (typeof value === "bigint") {
        return hash(lebEncode(value));
    }
    throw Object.assign(new Error(`Attempt to hash a value of unsupported type: ${value} of type ${typeof value}`), {
        value,
    });
}
const hashString = (value) => {
    const encoder = new TextEncoder('utf-8');
    const encoded = encoder.encode(value);
    return hash(Buffer.from(encoded));
};
function concat(bs) {
    return blobFromBuffer(Buffer.concat(bs));
}
export function requestIdOf(request) {
    const hashed = Object.entries(request)
        .filter(([, value]) => value !== undefined)
        .map(([key, value]) => {
        const hashedKey = hashString(key);
        const hashedValue = hashValue(value);
        return [hashedKey, hashedValue];
    });
    const traversed = hashed;
    const sorted = traversed.sort(([k1], [k2]) => {
        return Buffer.compare(Buffer.from(k1), Buffer.from(k2));
    });
    const concatenated = concat(sorted.map(concat));
    const requestId = hash(concatenated);
    return requestId;
}
