import CryptoJS from "crypto-js";
import { Principal } from "@dfinity/principal";
import { Buffer } from "buffer/";
import { byteArrayToWordArray, generateChecksum, wordArrayToByteArray, } from "./crypto";
const ACCOUNT_DOMAIN_SEPERATOR = "\x0Aaccount-id";
const SUB_ACCOUNT_ZERO = Buffer.alloc(32);
export const getAccountId = (principal, subAccount) => {
    const sha = CryptoJS.algo.SHA224.create();
    sha.update(ACCOUNT_DOMAIN_SEPERATOR);
    sha.update(byteArrayToWordArray(principal.toUint8Array()));
    const subBuffer = Buffer.from(SUB_ACCOUNT_ZERO);
    if (subAccount) {
        subBuffer.writeUInt32BE(subAccount, 0);
    }
    sha.update(byteArrayToWordArray(subBuffer));
    const hash = sha.finalize();
    const byteArray = wordArrayToByteArray(hash, 28);
    const checksum = generateChecksum(new Uint8Array(byteArray));
    const val = checksum + hash.toString();
    return val;
};
export const PRINCIPAL_REGEX = /(\w{5}-){10}\w{3}/;
export const CANISTER_MAX_LENGTH = 27;
export const ALPHANUM_REGEX = /^[a-zA-Z0-9]+$/;
export const isValidPrincipal = (text) => Principal.fromText(text).toText() === text;
export const validatePrincipalId = (text) => {
    try {
        return Boolean(PRINCIPAL_REGEX.test(text) && isValidPrincipal(text));
    }
    catch (e) {
        return false;
    }
};
export const validateAccountId = (text) => text.length === 64 && ALPHANUM_REGEX.test(text);
export const validateCanisterId = (text) => {
    try {
        return Boolean(text.length <= CANISTER_MAX_LENGTH && isValidPrincipal(text));
    }
    catch (e) {
        return false;
    }
};
export const validateToken = (metadata) => Boolean(!!metadata.decimal && !!metadata.name && !!metadata.symbol);
