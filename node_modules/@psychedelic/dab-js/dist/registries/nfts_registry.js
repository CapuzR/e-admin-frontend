"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCachedUserNFTs = exports.getBatchedNFTs = exports.getAllUserNFTs = exports.getAllNFTS = exports.getNFTInfo = exports.getNFTActor = exports.getUserCollectionTokens = exports.NFTRegistry = void 0;
const axios_1 = __importDefault(require("axios"));
const agent_1 = require("@dfinity/agent");
const principal_1 = require("@dfinity/principal");
const cross_fetch_1 = __importDefault(require("cross-fetch"));
const ext_1 = __importDefault(require("../standard_wrappers/nft_standards/ext"));
const ic_punks_1 = __importDefault(require("../standard_wrappers/nft_standards/ic_punks"));
const nft_origyn_1 = __importDefault(require("../standard_wrappers/nft_standards/nft_origyn"));
const departure_labs_1 = __importDefault(require("../standard_wrappers/nft_standards/departure_labs"));
const dip_721_1 = __importDefault(require("../standard_wrappers/nft_standards/dip_721"));
const standards_1 = require("../constants/standards");
const constants_1 = require("../constants");
const nft_registry_did_1 = __importDefault(require("../idls/dab_registries/nft_registry.did"));
const standard_registry_1 = __importDefault(require("./standard_registry"));
const actorFactory_1 = require("../utils/actorFactory");
const registry_1 = require("../utils/registry");
const ccc_1 = __importDefault(require("../standard_wrappers/nft_standards/ccc"));
const CANISTER_ID = 'ctqxp-yyaaa-aaaah-abbda-cai';
const BATCH_AMOUNT = 5;
const NFT_STANDARDS = {
    [standards_1.NFT.ext]: ext_1.default,
    [standards_1.NFT.icpunks]: ic_punks_1.default,
    [standards_1.NFT.nftOrigyn]: nft_origyn_1.default,
    [standards_1.NFT.departuresLabs]: departure_labs_1.default,
    [standards_1.NFT.erc721]: dip_721_1.default,
    [standards_1.NFT.dip721]: dip_721_1.default,
    [standards_1.NFT.c3]: ccc_1.default
};
const DEFAULT_AGENT = new agent_1.HttpAgent({ fetch: cross_fetch_1.default, host: constants_1.IC_HOST });
class NFTRegistry extends standard_registry_1.default {
    constructor(agent) {
        super(CANISTER_ID, agent);
        this.getAll = () => __awaiter(this, void 0, void 0, function* () {
            const canistersMetadata = yield this.actor.get_all();
            return canistersMetadata.map(registry_1.formatMetadata);
        });
        this.actor = (0, actorFactory_1.generateActor)({ agent: agent || DEFAULT_AGENT, canisterId: CANISTER_ID, IDL: nft_registry_did_1.default });
    }
}
exports.NFTRegistry = NFTRegistry;
const getUserCollectionTokens = (collection, user, agent = DEFAULT_AGENT, callback = () => { }, debug = false) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const NFTActor = (0, exports.getNFTActor)({
            canisterId: collection.principal_id.toString(),
            agent,
            standard: collection.standard
        });
        const details = yield NFTActor.getUserTokens(user);
        const collectionDetails = {
            name: collection.name,
            canisterId: collection.principal_id.toString(),
            standard: collection.standard,
            description: collection.description,
            icon: collection.icon,
            tokens: details.map((detail) => (Object.assign(Object.assign({}, detail), { collection: collection.name }))),
        };
        if (callback) {
            yield (callback === null || callback === void 0 ? void 0 : callback(collectionDetails));
        }
        return collectionDetails;
    }
    catch (e) {
        if (debug) {
            console.error(e);
        }
        return {
            name: collection.name,
            canisterId: collection.principal_id.toString(),
            standard: collection.standard,
            tokens: [],
        };
    }
});
exports.getUserCollectionTokens = getUserCollectionTokens;
const standardNormaliser = ({ standard }) => {
    const userStandardNormalised = standard.toUpperCase();
    const systemStandardNormalised = standards_1.NFT.dip721.toUpperCase();
    const startsWithDip721 = userStandardNormalised.startsWith(systemStandardNormalised);
    const hasSuffix = userStandardNormalised.split(systemStandardNormalised).filter(v => v).length > 0;
    const hasDeprecatedDip721Term = startsWithDip721 && hasSuffix;
    if (hasDeprecatedDip721Term) {
        console.warn(`Warning! Use the term DIP721, not ${standard}, suffixed and others are being deprecated and support will be dropped soon!`);
        return standards_1.NFT.dip721;
    }
    return userStandardNormalised;
};
const getNFTActor = ({ canisterId, agent, standard }) => {
    // We might need to override deprecated standards
    // which is computed by the standardNormaliser
    const standardNormalised = standardNormaliser({
        standard,
    });
    if (!(standardNormalised in NFT_STANDARDS)) {
        console.error(`Standard ${standardNormalised} is not implemented`);
        throw new Error(`standard is not supported: ${standardNormalised}`);
    }
    return new NFT_STANDARDS[standardNormalised](canisterId, agent);
};
exports.getNFTActor = getNFTActor;
const getNFTInfo = ({ nftCanisterId, agent = DEFAULT_AGENT }) => __awaiter(void 0, void 0, void 0, function* () {
    const registry = new NFTRegistry(agent);
    const result = yield registry.get(nftCanisterId);
    if (!result)
        return result;
    return Object.assign(Object.assign({}, result), { icon: result.thumbnail, standard: result.details.standard });
});
exports.getNFTInfo = getNFTInfo;
const getAllNFTS = ({ agent = DEFAULT_AGENT } = {}) => __awaiter(void 0, void 0, void 0, function* () {
    const registry = new NFTRegistry(agent);
    const allNFTs = yield registry.getAll();
    return allNFTs.map((nft) => (Object.assign(Object.assign({}, nft), { icon: nft.thumbnail, standard: nft.details.standard })));
});
exports.getAllNFTS = getAllNFTS;
const getAllUserNFTs = ({ user, agent = DEFAULT_AGENT, debug = false, }) => __awaiter(void 0, void 0, void 0, function* () {
    const NFTCollections = yield (0, exports.getAllNFTS)({ agent });
    const userPrincipal = user instanceof principal_1.Principal ? user : principal_1.Principal.fromText(user);
    const result = yield Promise.all(NFTCollections.map((collection) => (0, exports.getUserCollectionTokens)(collection, userPrincipal, agent, () => { }, debug)));
    return result.filter((element) => element.tokens.length);
});
exports.getAllUserNFTs = getAllUserNFTs;
const getBatchedNFTs = ({ principal, callback, batchSize = BATCH_AMOUNT, onFinish, agent = DEFAULT_AGENT, }) => __awaiter(void 0, void 0, void 0, function* () {
    const NFTCollections = yield (0, exports.getAllNFTS)({ agent });
    let result = [];
    for (let i = 0; i < NFTCollections.length; i += batchSize) {
        const batch = NFTCollections.slice(i, i + batchSize);
        const batchResult = yield Promise.all(batch.map(collection => (0, exports.getUserCollectionTokens)(collection, principal, agent, callback)));
        result = [...result, ...batchResult];
    }
    if (onFinish) {
        yield (onFinish === null || onFinish === void 0 ? void 0 : onFinish(result));
    }
    return result.filter((element) => { var _a; return (_a = element === null || element === void 0 ? void 0 : element.tokens) === null || _a === void 0 ? void 0 : _a.length; });
});
exports.getBatchedNFTs = getBatchedNFTs;
const getCachedUserNFTs = ({ userPID, refresh }) => __awaiter(void 0, void 0, void 0, function* () {
    const url = `${constants_1.KYASSHU_URL}/dab/user/nfts/${userPID}`;
    const result = yield axios_1.default.get(url, { params: { refresh } });
    return result.data;
});
exports.getCachedUserNFTs = getCachedUserNFTs;
exports.default = {
    getBatchedNFTs: exports.getBatchedNFTs,
    getNFTActor: exports.getNFTActor,
    getNFTInfo: exports.getNFTInfo,
    getAllNFTS: exports.getAllNFTS,
    getAllUserNFTs: exports.getAllUserNFTs,
    getCachedUserNFTs: exports.getCachedUserNFTs,
};
