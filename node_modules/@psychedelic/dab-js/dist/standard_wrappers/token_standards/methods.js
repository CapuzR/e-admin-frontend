"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseAmountToSend = exports.getDecimalsFromMetadata = void 0;
const send = (_actor, _params) => __awaiter(void 0, void 0, void 0, function* () {
    throw Error('Standard Not Implemented');
});
const getMetadata = (_actor) => __awaiter(void 0, void 0, void 0, function* () {
    throw Error('Standard Not Implemented');
});
const getBalance = (_actor, _user) => __awaiter(void 0, void 0, void 0, function* () {
    throw Error('Standard Not Implemented');
});
const burnXTC = (_actor, _params) => __awaiter(void 0, void 0, void 0, function* () {
    throw Error('Standard Not Implemented');
});
const getDecimals = (_actor) => __awaiter(void 0, void 0, void 0, function* () {
    throw Error('Standard Not Implemented');
});
const getDecimalsFromMetadata = (metadata) => {
    return 'fungible' in metadata ? metadata.fungible.decimals : 0;
};
exports.getDecimalsFromMetadata = getDecimalsFromMetadata;
const parseAmountToSend = (amount, decimals) => {
    return BigInt(parseFloat(amount) * Math.pow(10, decimals));
};
exports.parseAmountToSend = parseAmountToSend;
exports.default = {
    send,
    getMetadata,
    getBalance,
    burnXTC,
    getDecimals,
};
