"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const agent_1 = require("@dfinity/agent");
const principal_1 = require("@dfinity/principal");
const methods_1 = require("./methods");
const getMetadata = (actor) => __awaiter(void 0, void 0, void 0, function* () {
    actor._balance;
    const token = agent_1.Actor.canisterIdOf(actor).toText();
    const extensions = yield actor._extensions();
    if (!extensions.includes('@ext/common'))
        throw new Error('The provided canister does not implement commont extension');
    const metadataResult = yield actor._metadata(token);
    if ('ok' in metadataResult)
        return metadataResult.ok;
    throw new Error(Object.keys(metadataResult.err)[0]);
});
const send = (actor, { to, from, amount }) => __awaiter(void 0, void 0, void 0, function* () {
    const dummyMemmo = new Array(32).fill(0);
    const token = agent_1.Actor.canisterIdOf(actor).toText();
    const data = {
        to: { principal: principal_1.Principal.fromText(to) },
        from: { principal: principal_1.Principal.from(from) },
        amount,
        token,
        memo: dummyMemmo,
        notify: false,
        subaccount: [],
        fee: BigInt(0),
    };
    const transferResult = yield actor._transfer(data);
    if ('ok' in transferResult)
        return { amount: transferResult.ok.toString() };
    throw new Error(Object.keys(transferResult.err)[0]);
});
const getBalance = (actor, user) => __awaiter(void 0, void 0, void 0, function* () {
    const token = agent_1.Actor.canisterIdOf(actor).toText();
    const balanceResult = yield actor._balance({
        token,
        user: { principal: user },
    });
    const decimals = yield getDecimals(actor);
    if ('ok' in balanceResult)
        return { value: balanceResult.ok.toString(), decimals };
    throw new Error(Object.keys(balanceResult.err)[0]);
});
const burnXTC = (_actor, _params) => __awaiter(void 0, void 0, void 0, function* () {
    throw new Error('BURN NOT SUPPORTED');
});
const getDecimals = (actor) => __awaiter(void 0, void 0, void 0, function* () { return (0, methods_1.getDecimalsFromMetadata)(yield getMetadata(actor)); });
exports.default = {
    send,
    getMetadata,
    getBalance,
    burnXTC,
    getDecimals
};
