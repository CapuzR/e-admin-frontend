"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable @typescript-eslint/camelcase */
const principal_1 = require("@dfinity/principal");
const methods_1 = require("./methods");
const getMetadata = (actor) => __awaiter(void 0, void 0, void 0, function* () {
    const metadataResult = yield actor._getMetadata();
    return {
        fungible: {
            symbol: metadataResult.symbol,
            decimals: metadataResult.decimals,
            name: metadataResult.name,
            logo: metadataResult.logo,
            fee: metadataResult.fee,
            totalSupply: metadataResult.totalSupply,
            owner: metadataResult.owner,
        },
    };
});
const send = (actor, { to, amount }) => __awaiter(void 0, void 0, void 0, function* () {
    const transferResult = yield actor._transferErc20(principal_1.Principal.fromText(to), amount);
    if ('Ok' in transferResult)
        return { transactionId: transferResult.Ok.toString() };
    throw new Error(Object.keys(transferResult.Err)[0]);
});
const getBalance = (actor, user) => __awaiter(void 0, void 0, void 0, function* () {
    const decimals = yield getDecimals(actor);
    const value = (yield actor._balanceOf(user)).toString();
    return { value, decimals };
});
const burnXTC = (actor, { to, amount }) => __awaiter(void 0, void 0, void 0, function* () {
    const decimals = yield getDecimals(actor);
    const parsedAmount = (0, methods_1.parseAmountToSend)(amount, decimals);
    return actor._burn({ canister_id: to, amount: parsedAmount });
});
const getDecimals = (actor) => __awaiter(void 0, void 0, void 0, function* () { return (0, methods_1.getDecimalsFromMetadata)(yield getMetadata(actor)); });
exports.default = {
    send,
    getMetadata,
    getBalance,
    burnXTC,
    getDecimals,
};
