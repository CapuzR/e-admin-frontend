'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var defineProperty = require('./defineProperty-56a1d3f2.cjs.dev.js');
var xstate = require('xstate');
var agent = require('@dfinity/agent');
var Emitter = require('event-e3');
var neverthrow = require('neverthrow');
var connectors = require('./connectors-7c349a85.cjs.dev.js');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var Emitter__default = /*#__PURE__*/_interopDefault(Emitter);

const authStates = {
  id: "auth",
  initial: "initializing",
  schema: {
    context: {},
    events: {}
  },
  states: {
    initializing: {
      on: {
        DONE: {
          target: "idle",
          actions: xstate.assign((context, event) => ({
            providers: event.data.providers
          }))
        },
        DONE_AND_CONNECTED: {
          target: "connected",
          actions: [xstate.assign((context, event) => ({
            providers: event.data.providers,
            activeProvider: event.data.activeProvider,
            principal: event.data.principal
          }))]
        },
        ERROR: {// ?
        }
      },
      invoke: {
        id: "init",
        src: (context, event) => async (callback, onReceive) => {
          const {
            providers
          } = context;
          await Promise.all(providers.map(p => p.init()));
          let connectedProviders = providers.map(p => new Promise(async (resolve, reject) => {
            const isConnected = await p.isConnected();
            isConnected ? resolve(p) : reject();
          })); // TODO: init failure

          Promise.any(connectedProviders).then(connectedProvider => {
            callback({
              type: "DONE_AND_CONNECTED",
              data: {
                providers,
                activeProvider: connectedProvider,
                principal: connectedProvider.principal
              }
            });
          }).catch(e => {
            callback({
              type: "DONE",
              data: {
                providers
              }
            });
          });
        }
      },
      exit: ["onInit"]
    },
    idle: {
      on: {
        CONNECT: {
          // actions: forwardTo("connectService"),
          target: "connecting" // TODO: save connecting provider?

        }
      }
    },
    connecting: {
      entry: ["onConnecting"],
      on: {
        CONNECT: {
          // actions: forwardTo("connectService"),
          target: "connecting" // TODO: save connecting provider?

        },
        CANCEL_CONNECT: {
          target: "idle"
        },
        CONNECT_DONE: {
          target: "connected",
          actions: [xstate.assign((context, event) => ({
            activeProvider: event.data.activeProvider,
            principal: event.data.principal
          }))]
        },
        ERROR: {// actions: assign((context, event) => {
          //   return ({
          //     provider: event.data.provider,
          //     principal: event.data.principal,
          //   })
          // }),
        }
      },
      invoke: {
        id: "connectService",
        // src: "connectService",
        src: (context, _event) => async (callback, onReceive) => {
          // onReceive(async (e) => {
          //   // TODO: Handle cancellation with AbortController?
          //   // if (e.type === "CONNECT") {
          //   // }
          // })
          if (_event.type !== "CONNECT") {
            return;
          }

          const provider = context.providers.find(p => p.meta.id === _event.data.provider);

          if (!provider) {
            callback({
              type: "ERROR",
              data: {
                error: "Provider not found"
              }
            });
            return;
          }

          const result = await provider.connect();
          result.match(() => {
            callback({
              type: "CONNECT_DONE",
              data: {
                activeProvider: provider,
                principal: provider.principal
              }
            });
          }, e => {
            console.error(e);
            callback({
              type: "ERROR",
              data: {
                error: _event
              }
            });
          });
        },
        autoForward: true
      }
    },
    connected: {
      entry: ["onConnect"],
      invoke: {
        id: "actorService",
        src: "actorService",
        autoForward: true
      },
      on: {
        DISCONNECT: {
          target: "disconnecting" // TODO: pass provider?

        },
        SAVE_ACTOR: {
          actions: xstate.assign((context, event) => ({
            actors: { ...context.actors,
              [event.data.canisterName]: event.data.actor
            }
          }))
        }
      }
    },
    disconnecting: {
      invoke: {
        id: "disconnect",
        src: (context, event) => async () => {
          var _context$activeProvid;

          await ((_context$activeProvid = context.activeProvider) === null || _context$activeProvid === void 0 ? void 0 : _context$activeProvid.disconnect());
        },
        onDone: {
          target: "idle",
          // TODO: empty context
          actions: [xstate.assign((context, event) => ({
            activeProvider: undefined,
            actors: {},
            principal: undefined
          })), "onDisconnect"]
        },
        onError: {
          target: "connected",
          actions: []
        }
      }
    }
  }
};

class Client {
  constructor(service, emitter, config) {
    defineProperty._defineProperty(this, "_service", void 0);

    defineProperty._defineProperty(this, "config", void 0);

    defineProperty._defineProperty(this, "_emitter", void 0);

    this._service = service;
    this._emitter = emitter;
    this.config = config;
  }

  on(evt, fn) {
    this._emitter.on(evt, fn);

    return () => this._emitter.off(evt, fn);
  }

  subscribe(fn) {
    const sub = this._service.subscribe(fn);

    return sub.unsubscribe;
  }

  connect(provider) {
    this._service.send({
      type: "CONNECT",
      data: {
        provider
      }
    });
  }

  cancelConnect() {
    this._service.send({
      type: "CANCEL_CONNECT"
    });
  }

  disconnect() {
    this._service.send({
      type: "DISCONNECT"
    });
  }

  get providers() {
    return this._service.state.context.providers;
  }

  get activeProvider() {
    return this._service.state.context.activeProvider;
  }

  get principal() {
    return this._service.state.context.principal;
  }

  get actors() {
    return this._service.state.context.actors;
  }

  get anonymousActors() {
    return this._service.state.context.anonymousActors;
  }

  get status() {
    return this._service.state.value;
  }

}

const createClient = _ref => {
  let {
    canisters = {},
    providers: p = [],
    globalProviderConfig = {}
  } = _ref;
  const config = {
    dev: true,
    autoConnect: true,
    host: window.location.origin,
    whitelist: Object.values(canisters).map(canister => canister.canisterId),
    ...globalProviderConfig
  };
  const providers = typeof p === "function" ? p(config) : p;
  providers.forEach(p => p.config = config);
  const agent$1 = new agent.HttpAgent({
    host: config.host
  });

  if (config.dev) {
    // TODO: handle errors
    // try {
    agent$1.fetchRootKey().catch(e => console.error(e)); // } catch (e) {
    //
    // }
  }

  const anonymousActors = Object.entries(canisters).map(_ref2 => {
    let [canisterName, val] = _ref2;
    const {
      canisterId,
      idlFactory
    } = val;
    const actor = agent.Actor.createActor(idlFactory, {
      agent: agent$1,
      canisterId
    });
    return {
      actor,
      canisterName,
      idlFactory,
      canisterId
    };
  }).reduce((acc, _ref3) => {
    let {
      canisterName,
      actor
    } = _ref3;
    return { ...acc,
      [canisterName]: neverthrow.ok(actor)
    };
  }, {});
  const emitter = new Emitter__default["default"]();
  const rootMachine = xstate.createMachine({
    id: "root",
    initial: "idle",
    context: { ...config,
      providers,
      anonymousActors,
      canisters,
      actors: {},
      principal: undefined,
      activeProvider: undefined
    },
    schema: {
      context: {},
      events: {}
    },
    states: {
      idle: { ...authStates
      }
    }
  }, {
    services: {
      actorService: (context, _event) => (callback, onReceive) => {
        onReceive(async e => {
          if (e.type === "CREATE_ACTOR") {
            // TODO: why type error
            const result = await context.activeProvider.createActor(e.data.canisterId, e.data.idlFactory);
            callback({
              type: "SAVE_ACTOR",
              data: {
                actor: result,
                canisterName: e.data.canisterName
              }
            }); // result.match(
            //   (actor) => {
            //     callback({ type: "SAVE_ACTOR", data: { actor: result, canisterName: e.data.canisterName } })
            //   },
            //   (error) => {
            //     // TODO: ?
            //     callback({ type: "ERROR", data: { error } })
            //   },
            // )
          }
        }); // Initialize

        Object.keys(context.canisters).forEach(async canisterName => {
          const {
            canisterId,
            idlFactory
          } = context.canisters[canisterName]; // TODO: why type error

          const result = await context.activeProvider.createActor(canisterId, idlFactory);
          callback({
            type: "SAVE_ACTOR",
            data: {
              actor: result,
              canisterName
            }
          });
        });
      }
    },
    actions: {
      onDisconnect: () => {
        emitter.emit("disconnect");
      },
      onInit: () => {
        emitter.emit("init");
      },
      onConnect: (context, event) => {
        emitter.emit("connect", event.data); // TODO: check if works

        return xstate.assign({
          connectingProvider: event.data
        });
      },
      onConnecting: () => {
        emitter.emit("connecting");
      },
      onDisconnecting: () => {
        emitter.emit("disconnecting");
      }
    }
  });
  const service = xstate.interpret(rootMachine, {
    devTools: true
  });
  service.start();
  return new Client(service, emitter, config);
};

Object.defineProperty(exports, 'BalanceError', {
  enumerable: true,
  get: function () { return connectors.BalanceError; }
});
Object.defineProperty(exports, 'ConnectError', {
  enumerable: true,
  get: function () { return connectors.ConnectError; }
});
Object.defineProperty(exports, 'CreateActorError', {
  enumerable: true,
  get: function () { return connectors.CreateActorError; }
});
Object.defineProperty(exports, 'DisconnectError', {
  enumerable: true,
  get: function () { return connectors.DisconnectError; }
});
Object.defineProperty(exports, 'InitError', {
  enumerable: true,
  get: function () { return connectors.InitError; }
});
Object.defineProperty(exports, 'TransferError', {
  enumerable: true,
  get: function () { return connectors.TransferError; }
});
exports.createClient = createClient;
