import { Interpreter } from "xstate";
import type { ActorSubclass } from "@dfinity/agent";
import type { IDL } from "@dfinity/candid";
import type { CreateActorResult, IConnector } from "./providers/connectors";
import { Result } from "neverthrow";
import { CreateActorError } from "./providers/connectors";
declare type Provider = IConnector;
export declare type RootContext = {
    host: string;
    dev: boolean;
    autoConnect: boolean;
    whitelist: Array<string>;
    principal?: string;
    activeProvider?: Provider;
    providers: Array<Provider>;
    connectingProvider?: string;
    canisters: {
        [canisterName: string]: {
            canisterId: string;
            idlFactory: IDL.InterfaceFactory;
        };
    };
    actors: {
        [canisterName: string]: Result<ActorSubclass, {
            kind: CreateActorError;
        }>;
    };
    anonymousActors: {
        [canisterName: string]: Result<ActorSubclass, {
            kind: CreateActorError;
        }>;
    };
};
declare type DoneEvent = {
    type: "DONE";
    data: {
        providers: Array<Provider>;
    };
};
declare type DoneAndConnectedEvent = {
    type: "DONE_AND_CONNECTED";
    data: {
        activeProvider: Provider;
        providers: Array<Provider>;
        principal: string;
    };
};
declare type ConnectEvent = {
    type: "CONNECT";
    data: {
        provider: string;
    };
};
declare type CancelConnectEvent = {
    type: "CANCEL_CONNECT";
};
declare type ConnectDoneEvent = {
    type: "CONNECT_DONE";
    data: {
        activeProvider: Provider;
        principal: string;
    };
};
declare type DisconnectEvent = {
    type: "DISCONNECT";
};
declare type ErrorEvent = {
    type: "ERROR";
    data: {
        error: any;
    };
};
declare type CreateActorEvent = {
    type: "CREATE_ACTOR";
    data: {
        canisterName: string;
        canisterId: string;
        idlFactory: IDL.InterfaceFactory;
    };
};
declare type SaveActorEvent<Service> = {
    type: "SAVE_ACTOR";
    data: {
        actor: CreateActorResult<Service>;
        canisterName: string;
    };
};
declare type CreateAnonymousActorEvent = {
    type: "CREATE_ANONYMOUS_ACTOR";
    data: {
        canisterName: string;
        canisterId: string;
        idlFactory: IDL.InterfaceFactory;
    };
};
declare type SaveAnonymousActorEvent<Service> = {
    type: "SAVE_ANONYMOUS_ACTOR";
    data: {
        actor: CreateActorResult<Service>;
        canisterName: string;
    };
};
export declare type RootEvent<Service = any> = DoneEvent | ConnectDoneEvent | DoneAndConnectedEvent | ConnectEvent | CancelConnectEvent | DisconnectEvent | ErrorEvent | CreateActorEvent | SaveActorEvent<Service> | CreateAnonymousActorEvent | SaveAnonymousActorEvent<Service>;
declare type Config = {
    whitelist?: Array<string>;
    host?: string;
    dev?: boolean;
    autoConnect?: boolean;
    providerUrl?: string;
    ledgerCanisterId?: string;
    ledgerHost?: string;
    appName?: string;
};
declare type ClientOptions = {
    providers: Array<Provider> | ((config: Config) => Array<Provider>);
    canisters?: {
        [canisterName: string]: {
            canisterId: string;
            idlFactory: IDL.InterfaceFactory;
        };
    };
    globalProviderConfig?: {
        whitelist?: Array<string>;
        host?: string;
        dev?: boolean;
        autoConnect?: boolean;
        ledgerCanisterId?: string;
        ledgerHost?: string;
        appName?: string;
    };
};
declare class Client {
    _service: Interpreter<RootContext, any, RootEvent>;
    config: any;
    private _emitter;
    constructor(service: any, emitter: any, config: any);
    on(evt: any, fn: any): () => void;
    subscribe(fn: any): () => void;
    connect(provider: any): void;
    cancelConnect(): void;
    disconnect(): void;
    get providers(): IConnector[];
    get activeProvider(): IConnector | undefined;
    get principal(): string | undefined;
    get actors(): {
        [canisterName: string]: Result<ActorSubclass<Record<string, import("@dfinity/agent").ActorMethod<unknown[], unknown>>>, {
            kind: CreateActorError;
        }>;
    };
    get anonymousActors(): {
        [canisterName: string]: Result<ActorSubclass<Record<string, import("@dfinity/agent").ActorMethod<unknown[], unknown>>>, {
            kind: CreateActorError;
        }>;
    };
    get status(): import("xstate").StateValue;
}
declare const createClient: ({ canisters, providers: p, globalProviderConfig, }: ClientOptions) => Client;
export type { Client, };
export { createClient };
