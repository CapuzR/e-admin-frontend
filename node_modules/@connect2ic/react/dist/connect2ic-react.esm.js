import React, { createContext, useState, useContext, useEffect } from 'react';
import { useSelector } from '@xstate/react';
import { TransferError } from '@connect2ic/core';
import { err } from 'neverthrow';

const Connect2ICContext = /*#__PURE__*/createContext({});

const Connect2ICProvider = _ref => {
  let {
    children,
    client
  } = _ref;
  const [open, setOpen] = useState(false);
  const dialog = {
    open: () => setOpen(true),
    close: () => setOpen(false),
    isOpen: open
  };
  return /*#__PURE__*/React.createElement(Connect2ICContext.Provider, {
    value: {
      client,
      dialog
    }
  }, children);
};

const useConnect = props => {
  var _client$_service$stat, _client$_service$stat2, _client$_service$stat3, _client$_service$stat4, _client$_service$stat5, _client$_service$stat6, _client$_service$stat7, _client$_service$stat8, _client$_service$stat9, _client$_service$stat10;

  // TODO: handle
  const {
    onConnect = () => {},
    onDisconnect = () => {}
  } = props !== null && props !== void 0 ? props : {};
  const {
    client
  } = useContext(Connect2ICContext);
  const {
    principal,
    activeProvider,
    status
  } = useSelector(client._service, state => ({
    principal: state.context.principal,
    activeProvider: state.context.activeProvider,
    status: state.value
  }));
  useEffect(() => {
    const unsub = client.on("connect", onConnect);
    const unsub2 = client.on("disconnect", onDisconnect);
    return () => {
      unsub();
      unsub2();
    };
  }, [client]);
  return {
    principal,
    activeProvider,
    status,
    isInitializing: (_client$_service$stat = (_client$_service$stat2 = client._service.state) === null || _client$_service$stat2 === void 0 ? void 0 : _client$_service$stat2.matches({
      idle: "initializing"
    })) !== null && _client$_service$stat !== void 0 ? _client$_service$stat : false,
    isConnected: (_client$_service$stat3 = (_client$_service$stat4 = client._service.state) === null || _client$_service$stat4 === void 0 ? void 0 : _client$_service$stat4.matches({
      idle: "connected"
    })) !== null && _client$_service$stat3 !== void 0 ? _client$_service$stat3 : false,
    isConnecting: (_client$_service$stat5 = (_client$_service$stat6 = client._service.state) === null || _client$_service$stat6 === void 0 ? void 0 : _client$_service$stat6.matches({
      idle: "connecting"
    })) !== null && _client$_service$stat5 !== void 0 ? _client$_service$stat5 : false,
    isDisconnecting: (_client$_service$stat7 = (_client$_service$stat8 = client._service.state) === null || _client$_service$stat8 === void 0 ? void 0 : _client$_service$stat8.matches({
      idle: "disconnecting"
    })) !== null && _client$_service$stat7 !== void 0 ? _client$_service$stat7 : false,
    isIdle: (_client$_service$stat9 = (_client$_service$stat10 = client._service.state) === null || _client$_service$stat10 === void 0 ? void 0 : _client$_service$stat10.matches({
      idle: "idle"
    })) !== null && _client$_service$stat9 !== void 0 ? _client$_service$stat9 : false,
    connect: provider => {
      client.connect(provider);
    },
    cancelConnect: () => {
      client.cancelConnect();
    },
    disconnect: () => {
      client.disconnect();
    }
  };
};

// TODO: ??
// @ts-ignore
const useCanister = function (canisterName) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    mode: "auto" // "anonymous" | "connected"

  };
  const {
    mode
  } = options;
  const {
    client
  } = useContext(Connect2ICContext);
  const anonymousActorResult = useSelector(client._service, state => state.context.anonymousActors[canisterName]);
  const actorResult = useSelector(client._service, state => state.context.actors[canisterName]);
  const canisterDefinition = useSelector(client._service, state => state.context.canisters[canisterName]);
  const {
    isConnected
  } = useConnect();
  const signedIn = isConnected && actorResult && mode !== "anonymous";
  const actor = signedIn ? actorResult : anonymousActorResult;
  return [actor.isOk() ? actor.value : undefined, {
    error: actor.isErr() ? actor.error : undefined,
    // TODO: ?
    loading: !actor,
    canisterDefinition
  }];
};

const useWallet = () => {
  const {
    client
  } = useContext(Connect2ICContext);
  const activeProvider = useSelector(client._service, state => state.context.activeProvider);
  const supportsWallet = !!(activeProvider !== null && activeProvider !== void 0 && activeProvider.meta.features.includes("wallet"));
  const {
    isConnected
  } = useConnect();
  const wallet = isConnected && supportsWallet ? activeProvider : undefined;
  return [wallet];
};

const useBalance = () => {
  // TODO: check if supported or not
  const [wallet] = useWallet();
  const {
    activeProvider
  } = useConnect();
  const [assets, setAssets] = useState();
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState();

  const refetch = async () => {
    var _queryBalance, _ref;

    if (!wallet || !activeProvider) {
      setAssets(undefined);
      return;
    }

    const result = await ((_queryBalance = (_ref = activeProvider).queryBalance) === null || _queryBalance === void 0 ? void 0 : _queryBalance.call(_ref));
    result.match(assets => {
      setAssets(assets);
    }, error => {
      setError(error);
    });
    setLoading(false);
    return result;
  };

  useEffect(() => {
    if (!wallet) {
      setAssets(undefined);
      return;
    }

    refetch();
  }, [wallet]);
  return [assets, {
    loading,
    error,
    refetch
  }];
};

const useDialog = function () {
  const {
    dialog
  } = useContext(Connect2ICContext);
  return dialog;
};

const useProviders = () => {
  const {
    client
  } = useContext(Connect2ICContext);
  const providers = useSelector(client._service, state => state.context.providers);
  return providers !== null && providers !== void 0 ? providers : [];
};

const useSignMessage = _ref => {
  let {
    message
  } = _ref;
  // TODO: check if supported or not
  const {
    activeProvider
  } = useConnect();
  const [wallet] = useWallet();

  const signMessage = () => {
    var _activeProvider$signM;

    if (!wallet || !activeProvider) {
      return;
    }

    (_activeProvider$signM = activeProvider.signMessage) === null || _activeProvider$signM === void 0 ? void 0 : _activeProvider$signM.call(activeProvider, {
      message
    });
  };

  const loading = false;
  const error = false;
  return [signMessage, {
    loading,
    error
  }];
};

const useTransfer = _ref => {
  let {
    amount,
    to,
    from = undefined
  } = _ref;
  // TODO: check if supported or not
  const [wallet] = useWallet();
  const {
    activeProvider,
    principal
  } = useConnect();
  const [loading, setLoading] = useState(false);
  const [payload, setPayload] = useState();
  const [error, setError] = useState();

  const transfer = async () => {
    if (!wallet || !activeProvider) {
      return err({
        kind: TransferError.NotConnected
      });
    }

    setLoading(true);
    const result = await activeProvider.requestTransfer({
      amount,
      to
    });
    result.match(payload => {
      // TODO: ?
      setPayload(payload);
    }, error => {
      setError(error);
    });
    setLoading(false);
    return result;
  };

  return [transfer, {
    loading,
    error
  }];
};

const useClient = () => {
  const {
    client
  } = useContext(Connect2ICContext);
  return client;
};

const ConnectButton = props => {
  const {
    style = {},
    dark = false,
    onConnect = () => {},
    onDisconnect = () => {},
    children
  } = props;
  const dialog = useDialog();
  const {
    disconnect,
    isConnected
  } = useConnect({
    onConnect,
    onDisconnect
  });
  return /*#__PURE__*/React.createElement(React.Fragment, null, !isConnected ? /*#__PURE__*/React.createElement("button", {
    onClick: () => dialog.open(),
    style: style,
    className: "connect-button"
  }, children !== null && children !== void 0 ? children : "Connect") : null, isConnected ? /*#__PURE__*/React.createElement("button", {
    onClick: disconnect,
    style: style,
    className: "connect-button"
  }, children !== null && children !== void 0 ? children : "Disconnect") : null);
};

var ConnectButton$1 = ConnectButton;

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends.apply(this, arguments);
}

const ConnectDialog = props => {
  const {
    onClose = () => {
      dialog.close();
    },
    children,
    dark
  } = props;
  const dialog = useDialog();
  const providers = useProviders();
  const {
    connect,
    isConnected
  } = useConnect();
  useEffect(() => {
    if (isConnected) {
      dialog.close();
    }
  }, [isConnected]);
  useEffect(() => {
    if (dialog.isOpen) {
      document.body.style.overflow = "hidden";
    }

    if (!dialog.isOpen) {
      document.body.style.overflow = "unset";
    }
  }, [dialog.isOpen]);
  useEffect(() => {
    const handleEsc = event => {
      if (event.keyCode === 27) {
        dialog.close();
      }
    };

    window.addEventListener("keydown", handleEsc);
    return () => {
      window.removeEventListener("keydown", handleEsc);
    };
  }, []);

  const onClickInside = e => {
    e.stopPropagation();
  };

  return dialog.isOpen ? /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("div", {
    className: "dialog-styles ".concat(dark ? "dark" : "light"),
    onClick: onClose
  }, /*#__PURE__*/React.createElement("div", {
    onClick: onClickInside,
    className: "dialog-container"
  }, /*#__PURE__*/React.createElement("div", null, providers.map(provider => {
    return /*#__PURE__*/React.createElement("button", _extends({
      key: provider.meta.id,
      onClick: () => connect(provider.meta.id),
      className: "button-styles ".concat(provider.meta.id, "-styles")
    }, props), /*#__PURE__*/React.createElement("img", {
      className: "img-styles",
      src: dark ? provider.meta.icon.dark : provider.meta.icon.light
    }), /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement("span", {
      className: "button-label"
    }, provider.meta.name)));
  }))))) : null;
};

var ConnectDialog$1 = ConnectDialog;

export { Connect2ICContext, Connect2ICProvider, ConnectButton$1 as ConnectButton, ConnectDialog$1 as ConnectDialog, useBalance, useCanister, useClient, useConnect, useDialog, useProviders, useSignMessage, useTransfer, useWallet };
